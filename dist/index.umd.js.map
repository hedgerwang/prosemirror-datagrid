{"version":3,"file":"index.umd.js","mappings":"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","sources":["webpack://prosemirror-datagrid/webpack/universalModuleDefinition","webpack://prosemirror-datagrid/./datagrid/CanvasDataGrid.css","webpack://prosemirror-datagrid/./datagrid/CellEditor.css","webpack://prosemirror-datagrid/../node_modules/css-loader/dist/runtime/api.js","webpack://prosemirror-datagrid/../node_modules/css-loader/dist/runtime/cssWithMappingToString.js","webpack://prosemirror-datagrid/../node_modules/nullthrows/nullthrows.js","webpack://prosemirror-datagrid/../node_modules/orderedmap/index.es.js","webpack://prosemirror-datagrid/../node_modules/prosemirror-model/dist/index.es.js","webpack://prosemirror-datagrid/../node_modules/prosemirror-state/dist/index.es.js","webpack://prosemirror-datagrid/../node_modules/prosemirror-transform/dist/index.es.js","webpack://prosemirror-datagrid/webpack/bootstrap","webpack://prosemirror-datagrid/webpack/runtime/compat get default export","webpack://prosemirror-datagrid/webpack/runtime/define property getters","webpack://prosemirror-datagrid/webpack/runtime/hasOwnProperty shorthand","webpack://prosemirror-datagrid/webpack/runtime/make namespace object","webpack://prosemirror-datagrid/./datagrid/ProseMirrorDataGridElement.ts","webpack://prosemirror-datagrid/./datagrid/DataGridNodeSpec.ts","webpack://prosemirror-datagrid/./datagrid/insertDataGrid.ts","webpack://prosemirror-datagrid/./datagrid/createNodeSpecMap.ts","webpack://prosemirror-datagrid/./datagrid/Vector.ts","webpack://prosemirror-datagrid/./datagrid/Box.ts","webpack://prosemirror-datagrid/./datagrid/DOMEventsHandler.ts","webpack://prosemirror-datagrid/./datagrid/clamp.ts","webpack://prosemirror-datagrid/./datagrid/CanvasDataGridRenderingContext.ts","webpack://prosemirror-datagrid/./datagrid/getCellEntryKey.ts","webpack://prosemirror-datagrid/./datagrid/getIndexRowCellText.ts","webpack://prosemirror-datagrid/./datagrid/getCellEntryContent.ts","webpack://prosemirror-datagrid/./datagrid/renderCanvasDataGrid.ts","webpack://prosemirror-datagrid/./datagrid/CellSelection.ts","webpack://prosemirror-datagrid/./datagrid/CanvasDataGridConfig.ts","webpack://prosemirror-datagrid/./datagrid/SegmentList.ts","webpack://prosemirror-datagrid/./datagrid/canvasDataGridActions.ts","webpack://prosemirror-datagrid/./datagrid/createStyleElement.ts","webpack://prosemirror-datagrid/./datagrid/CellEditor.ts","webpack://prosemirror-datagrid/./datagrid/createCanvasDataGridState.ts","webpack://prosemirror-datagrid/./datagrid/CanvasDataGrid.ts","webpack://prosemirror-datagrid/./datagrid/canvasDataGridReducer.ts","webpack://prosemirror-datagrid/./datagrid/findCellBox.ts","webpack://prosemirror-datagrid/./datagrid/setCellEntryContent.ts","webpack://prosemirror-datagrid/./datagrid/findCellAtPoint.ts","webpack://prosemirror-datagrid/./datagrid/DataGridNodeView.ts","webpack://prosemirror-datagrid/./datagrid/createNodeViewsMap.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"prosemirror-datagrid\"] = factory();\n\telse\n\t\troot[\"prosemirror-datagrid\"] = factory();\n})(self, function() {\nreturn ","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".CanvasDataGrid_main---3G-U {\\n  background: #ccc;\\n  box-sizing: border-box;\\n  display: block;\\n  font-size: 0;\\n  line-height: 0;\\n  outline: solid 1px #ccc;\\n  position: relative;\\n}\\n\\n.CanvasDataGrid_main---3G-U[data-active='true'] {\\n  box-shadow: 0 0 3px 2px rgb(80, 134, 236);\\n}\\n\\n.CanvasDataGrid_canvas--19oEJ {\\n  background: #fff;\\n  border: none;\\n  outline: none;\\n  margin: 0;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./datagrid/CanvasDataGrid.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,gBAAgB;EAChB,sBAAsB;EACtB,cAAc;EACd,YAAY;EACZ,cAAc;EACd,uBAAuB;EACvB,kBAAkB;AACpB;;AAEA;EACE,yCAAyC;AAC3C;;AAEA;EACE,gBAAgB;EAChB,YAAY;EACZ,aAAa;EACb,SAAS;AACX\",\"sourcesContent\":[\".main {\\n  background: #ccc;\\n  box-sizing: border-box;\\n  display: block;\\n  font-size: 0;\\n  line-height: 0;\\n  outline: solid 1px #ccc;\\n  position: relative;\\n}\\n\\n.main[data-active='true'] {\\n  box-shadow: 0 0 3px 2px rgb(80, 134, 236);\\n}\\n\\n.canvas {\\n  background: #fff;\\n  border: none;\\n  outline: none;\\n  margin: 0;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"main\": \"CanvasDataGrid_main---3G-U\",\n\t\"canvas\": \"CanvasDataGrid_canvas--19oEJ\"\n};\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".CellEditor_dom--3U-Bo {\\n  left: 0;\\n  position: absolute;\\n  top: 0;\\n  visibility: hidden;\\n}\\n\\n.CellEditor_input--3hzUS {\\n  padding: 6px;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./datagrid/CellEditor.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,kBAAkB;AACpB;;AAEA;EACE,YAAY;AACd\",\"sourcesContent\":[\".dom {\\n  left: 0;\\n  position: absolute;\\n  top: 0;\\n  visibility: hidden;\\n}\\n\\n.input {\\n  padding: 6px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"dom\": \"CellEditor_dom--3U-Bo\",\n\t\"input\": \"CellEditor_input--3hzUS\"\n};\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","'use strict';\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n  var error = new Error(message !== undefined ? message : 'Got unexpected ' + x);\n  error.framesToPop = 1; // Skip nullthrows's own stack frame.\n  throw error;\n}\n\nmodule.exports = nullthrows;\nmodule.exports.default = nullthrows;\n\nObject.defineProperty(module.exports, '__esModule', {value: true});\n","// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nvar orderedmap = OrderedMap;\n\nexport default orderedmap;\n","import OrderedMap from 'orderedmap';\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      { return a.childCount == b.childCount ? null : pos }\n\n    var childA = a.child(i), childB = b.child(i);\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) { return pos }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n        { pos++; }\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) { return inner }\n    }\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      { return iA == iB ? null : {a: posA, b: posB} }\n\n    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size; posB -= size;\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--;\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) { return inner }\n    }\n    posA -= size; posB -= size;\n  }\n}\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nvar Fragment = function Fragment(content, size) {\n  this.content = content;\n  // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n  this.size = size || 0;\n  if (size == null) { for (var i = 0; i < content.length; i++)\n    { this.size += content[i].nodeSize; } }\n};\n\nvar prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };\n\n// :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\nFragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {\n    if ( nodeStart === void 0 ) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start),\n                         Math.min(child.content.size, to - start),\n                         f, nodeStart + start);\n    }\n    pos = end;\n  }\n};\n\n// :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\nFragment.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.size, f);\n};\n\n// :: (number, number, ?string, ?string) → string\n// Extract the text between `from` and `to`. See the same method on\n// [`Node`](#model.Node.textBetween).\nFragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  var text = \"\", separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text\n};\n\n// :: (Fragment) → Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\nFragment.prototype.append = function append (other) {\n  if (!other.size) { return this }\n  if (!this.size) { return other }\n  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n  for (; i < other.content.length; i++) { content.push(other.content[i]); }\n  return new Fragment(content, this.size + other.size)\n};\n\n// :: (number, ?number) → Fragment\n// Cut out the sub-fragment between the two given positions.\nFragment.prototype.cut = function cut (from, to) {\n  if (to == null) { to = this.size; }\n  if (from == 0 && to == this.size) { return this }\n  var result = [], size = 0;\n  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from) {\n      if (pos < from || end > to) {\n        if (child.isText)\n          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }\n        else\n          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }\n      }\n      result.push(child);\n      size += child.nodeSize;\n    }\n    pos = end;\n  } }\n  return new Fragment(result, size)\n};\n\nFragment.prototype.cutByIndex = function cutByIndex (from, to) {\n  if (from == to) { return Fragment.empty }\n  if (from == 0 && to == this.content.length) { return this }\n  return new Fragment(this.content.slice(from, to))\n};\n\n// :: (number, Node) → Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\nFragment.prototype.replaceChild = function replaceChild (index, node) {\n  var current = this.content[index];\n  if (current == node) { return this }\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\nFragment.prototype.addToStart = function addToStart (node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\nFragment.prototype.addToEnd = function addToEnd (node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n};\n\n// :: (Fragment) → bool\n// Compare this fragment to another one.\nFragment.prototype.eq = function eq (other) {\n  if (this.content.length != other.content.length) { return false }\n  for (var i = 0; i < this.content.length; i++)\n    { if (!this.content[i].eq(other.content[i])) { return false } }\n  return true\n};\n\n// :: ?Node\n// The first child of the fragment, or `null` if it is empty.\nprototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\n// :: ?Node\n// The last child of the fragment, or `null` if it is empty.\nprototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\n// :: number\n// The number of child nodes in this fragment.\nprototypeAccessors.childCount.get = function () { return this.content.length };\n\n// :: (number) → Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\nFragment.prototype.child = function child (index) {\n  var found = this.content[index];\n  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n  return found\n};\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nFragment.prototype.maybeChild = function maybeChild (index) {\n  return this.content[index]\n};\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nFragment.prototype.forEach = function forEach (f) {\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n};\n\n// :: (Fragment) → ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\nFragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  return findDiffStart(this, other, pos)\n};\n\n// :: (Fragment) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\nFragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {\n    if ( pos === void 0 ) pos = this.size;\n    if ( otherPos === void 0 ) otherPos = other.size;\n\n  return findDiffEnd(this, other, pos, otherPos)\n};\n\n// : (number, ?number) → {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\nFragment.prototype.findIndex = function findIndex (pos, round) {\n    if ( round === void 0 ) round = -1;\n\n  if (pos == 0) { return retIndex(0, pos) }\n  if (pos == this.size) { return retIndex(this.content.length, pos) }\n  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this.child(i), end = curPos + cur.nodeSize;\n    if (end >= pos) {\n      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n      return retIndex(i, curPos)\n    }\n    curPos = end;\n  }\n};\n\n// :: () → string\n// Return a debugging string that describes this fragment.\nFragment.prototype.toString = function toString () { return \"<\" + this.toStringInner() + \">\" };\n\nFragment.prototype.toStringInner = function toStringInner () { return this.content.join(\", \") };\n\n// :: () → ?Object\n// Create a JSON-serializeable representation of this fragment.\nFragment.prototype.toJSON = function toJSON () {\n  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n};\n\n// :: (Schema, ?Object) → Fragment\n// Deserialize a fragment from its JSON representation.\nFragment.fromJSON = function fromJSON (schema, value) {\n  if (!value) { return Fragment.empty }\n  if (!Array.isArray(value)) { throw new RangeError(\"Invalid input for Fragment.fromJSON\") }\n  return new Fragment(value.map(schema.nodeFromJSON))\n};\n\n// :: ([Node]) → Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\nFragment.fromArray = function fromArray (array) {\n  if (!array.length) { return Fragment.empty }\n  var joined, size = 0;\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) { joined = array.slice(0, i); }\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n  return new Fragment(joined || array, size)\n};\n\n// :: (?union<Fragment, Node, [Node]>) → Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\nFragment.from = function from (nodes) {\n  if (!nodes) { return Fragment.empty }\n  if (nodes instanceof Fragment) { return nodes }\n  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }\n  throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                       (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n};\n\nObject.defineProperties( Fragment.prototype, prototypeAccessors );\n\nvar found = {index: 0, offset: 0};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) { return true }\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) { return false }\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) { return false }\n  if (array) {\n    if (a.length != b.length) { return false }\n    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n  } else {\n    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  }\n  return true\n}\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type;\n  // :: Object\n  // The attributes associated with this mark.\n  this.attrs = attrs;\n};\n\n// :: ([Mark]) → [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\nMark.prototype.addToSet = function addToSet (set) {\n  var copy, placed = false;\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n    if (this.eq(other)) { return set }\n    if (this.type.excludes(other.type)) {\n      if (!copy) { copy = set.slice(0, i); }\n    } else if (other.type.excludes(this.type)) {\n      return set\n    } else {\n      if (!placed && other.type.rank > this.type.rank) {\n        if (!copy) { copy = set.slice(0, i); }\n        copy.push(this);\n        placed = true;\n      }\n      if (copy) { copy.push(other); }\n    }\n  }\n  if (!copy) { copy = set.slice(); }\n  if (!placed) { copy.push(this); }\n  return copy\n};\n\n// :: ([Mark]) → [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\nMark.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i]))\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark]) → bool\n// Test whether this mark is in the given set of marks.\nMark.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i])) { return true } }\n  return false\n};\n\n// :: (Mark) → bool\n// Test whether this mark has the same type and attributes as\n// another mark.\nMark.prototype.eq = function eq (other) {\n  return this == other ||\n    (this.type == other.type && compareDeep(this.attrs, other.attrs))\n};\n\n// :: () → Object\n// Convert this mark to a JSON-serializeable representation.\nMark.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  return obj\n};\n\n// :: (Schema, Object) → Mark\nMark.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Mark.fromJSON\") }\n  var type = schema.marks[json.type];\n  if (!type) { throw new RangeError((\"There is no mark type \" + (json.type) + \" in this schema\")) }\n  return type.create(json.attrs)\n};\n\n// :: ([Mark], [Mark]) → bool\n// Test whether two sets of marks are identical.\nMark.sameSet = function sameSet (a, b) {\n  if (a == b) { return true }\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++)\n    { if (!a[i].eq(b[i])) { return false } }\n  return true\n};\n\n// :: (?union<Mark, [Mark]>) → [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\nMark.setFrom = function setFrom (marks) {\n  if (!marks || marks.length == 0) { return Mark.none }\n  if (marks instanceof Mark) { return [marks] }\n  var copy = marks.slice();\n  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });\n  return copy\n};\n\n// :: [Mark] The empty set of marks.\nMark.none = [];\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\";\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content;\n  // :: number The open depth at the start.\n  this.openStart = openStart;\n  // :: number The open depth at the end.\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$1 = { size: { configurable: true } };\n\n// :: number\n// The size this slice would add when inserted into a document.\nprototypeAccessors$1.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd\n};\n\nSlice.prototype.insertAt = function insertAt (pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd)\n};\n\nSlice.prototype.removeBetween = function removeBetween (from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n};\n\n// :: (Slice) → bool\n// Tests whether this slice is equal to another slice.\nSlice.prototype.eq = function eq (other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n};\n\nSlice.prototype.toString = function toString () {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n};\n\n// :: () → ?Object\n// Convert a slice to a JSON-serializable representation.\nSlice.prototype.toJSON = function toJSON () {\n  if (!this.content.size) { return null }\n  var json = {content: this.content.toJSON()};\n  if (this.openStart > 0) { json.openStart = this.openStart; }\n  if (this.openEnd > 0) { json.openEnd = this.openEnd; }\n  return json\n};\n\n// :: (Schema, ?Object) → Slice\n// Deserialize a slice from its JSON representation.\nSlice.fromJSON = function fromJSON (schema, json) {\n  if (!json) { return Slice.empty }\n  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n    { throw new RangeError(\"Invalid input for Slice.fromJSON\") }\n  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n};\n\n// :: (Fragment, ?bool) → Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\nSlice.maxOpen = function maxOpen (fragment, openIsolating) {\n    if ( openIsolating === void 0 ) openIsolating=true;\n\n  var openStart = 0, openEnd = 0;\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }\n  return new Slice(fragment, openStart, openEnd)\n};\n\nObject.defineProperties( Slice.prototype, prototypeAccessors$1 );\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) { return null }\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    { throw new ReplaceError(\"Inconsistent open depths\") }\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    var parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    { target[last] = child.withText(target[last].text + child.text); }\n  else\n    { target.push(child); }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }\n  if ($end && $end.depth == depth && $end.textOffset)\n    { addNode($end.nodeBefore, target); }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--)\n    { node = $along.node(i).copy(Fragment.from(node)); }\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path;\n  // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n  this.depth = path.length / 3 - 1;\n  // :: number The offset this position has into its parent node.\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };\n\nResolvedPos.prototype.resolveDepth = function resolveDepth (val) {\n  if (val == null) { return this.depth }\n  if (val < 0) { return this.depth + val }\n  return val\n};\n\n// :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parent—text nodes are ‘flat’ in this model, and have no content.\nprototypeAccessors$2.parent.get = function () { return this.node(this.depth) };\n\n// :: Node\n// The root node in which the position was resolved.\nprototypeAccessors$2.doc.get = function () { return this.node(0) };\n\n// :: (?number) → Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\nResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\n// :: (?number) → number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 1 and `p.index(1)` is 2.\nResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\n// :: (?number) → number\n// The index pointing after this position into the ancestor at the\n// given level.\nResolvedPos.prototype.indexAfter = function indexAfter (depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n};\n\n// :: (?number) → number\n// The (absolute) position at the start of the node at the given\n// level.\nResolvedPos.prototype.start = function start (depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n};\n\n// :: (?number) → number\n// The (absolute) position at the end of the node at the given\n// level.\nResolvedPos.prototype.end = function end (depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size\n};\n\n// :: (?number) → number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `depth` is `this.depth + 1`, the original\n// position.\nResolvedPos.prototype.before = function before (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n};\n\n// :: (?number) → number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `depth` is `this.depth + 1`.\nResolvedPos.prototype.after = function after (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n};\n\n// :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\nprototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\n// :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\nprototypeAccessors$2.nodeAfter.get = function () {\n  var parent = this.parent, index = this.index(this.depth);\n  if (index == parent.childCount) { return null }\n  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child\n};\n\n// :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\nprototypeAccessors$2.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n  return index == 0 ? null : this.parent.child(index - 1)\n};\n\n// :: (number, ?number) → number\n// Get the position at the given index in the parent node at the\n// given depth (which defaults to `this.depth`).\nResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {\n  depth = this.resolveDepth(depth);\n  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }\n  return pos\n};\n\n// :: () → [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\nResolvedPos.prototype.marks = function marks () {\n  var parent = this.parent, index = this.index();\n\n  // In an empty parent, return the empty array\n  if (parent.content.size == 0) { return Mark.none }\n\n  // When inside a text node, just return the text node's marks\n  if (this.textOffset) { return parent.child(index).marks }\n\n  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n  // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n  if (!main) { var tmp = main; main = other; other = tmp; }\n\n  // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n  var marks = main.marks;\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n\n  return marks\n};\n\n// :: (ResolvedPos) → ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\nResolvedPos.prototype.marksAcross = function marksAcross ($end) {\n  var after = this.parent.maybeChild(this.index());\n  if (!after || !after.isInline) { return null }\n\n  var marks = after.marks, next = $end.parent.maybeChild($end.index());\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n  return marks\n};\n\n// :: (number) → number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\nResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {\n  for (var depth = this.depth; depth > 0; depth--)\n    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }\n  return 0\n};\n\n// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\nResolvedPos.prototype.blockRange = function blockRange (other, pred) {\n    if ( other === void 0 ) other = this;\n\n  if (other.pos < this.pos) { return other.blockRange(this) }\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n      { return new NodeRange(this, other, d) } }\n};\n\n// :: (ResolvedPos) → bool\n// Query whether the given position shares the same parent node.\nResolvedPos.prototype.sameParent = function sameParent (other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the greater of this and the given position.\nResolvedPos.prototype.max = function max (other) {\n  return other.pos > this.pos ? other : this\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the smaller of this and the given position.\nResolvedPos.prototype.min = function min (other) {\n  return other.pos < this.pos ? other : this\n};\n\nResolvedPos.prototype.toString = function toString () {\n  var str = \"\";\n  for (var i = 1; i <= this.depth; i++)\n    { str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1); }\n  return str + \":\" + this.parentOffset\n};\n\nResolvedPos.resolve = function resolve (doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n  var path = [];\n  var start = 0, parentOffset = pos;\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n      var index = ref.index;\n      var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n    if (!rem) { break }\n    node = node.child(index);\n    if (node.isText) { break }\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n  return new ResolvedPos(pos, path, parentOffset)\n};\n\nResolvedPos.resolveCached = function resolveCached (doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n    if (cached.pos == pos && cached.doc == doc) { return cached }\n  }\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result\n};\n\nObject.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );\n\nvar resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from;\n  // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n  this.$to = $to;\n  // :: number The depth of the node that this range points into.\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };\n\n// :: number The position at the start of the range.\nprototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };\n// :: number The position at the end of the range.\nprototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\n// :: Node The parent node that the range points into.\nprototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };\n// :: number The start index of the range in the parent node.\nprototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };\n// :: number The end index of the range in the parent node.\nprototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\nObject.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );\n\nvar emptyAttrs = Object.create(null);\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type;\n\n  // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n  this.attrs = attrs;\n\n  // :: Fragment\n  // A container holding the node's children.\n  this.content = content || Fragment.empty;\n\n  // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// text:: ?string\n// For text nodes, this contains the node's text content.\n\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\nprototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\n// :: number\n// The number of children that the node has.\nprototypeAccessors$3.childCount.get = function () { return this.content.childCount };\n\n// :: (number) → Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\nNode.prototype.child = function child (index) { return this.content.child(index) };\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nNode.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nNode.prototype.forEach = function forEach (f) { this.content.forEach(f); };\n\n// :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\nNode.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {\n    if ( startPos === void 0 ) startPos = 0;\n\n  this.content.nodesBetween(from, to, f, startPos, this);\n};\n\n// :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\nNode.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.content.size, f);\n};\n\n// :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\nprototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\n// :: (number, number, ?string, ?string) → string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted whenever a new\n// block node is started. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\nNode.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText)\n};\n\n// :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\nprototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };\n\n// :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\nprototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };\n\n// :: (Node) → bool\n// Test whether two nodes represent the same piece of document.\nNode.prototype.eq = function eq (other) {\n  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n};\n\n// :: (Node) → bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\nNode.prototype.sameMarkup = function sameMarkup (other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks)\n};\n\n// :: (NodeType, ?Object, ?[Mark]) → bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\nNode.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {\n  return this.type == type &&\n    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n    Mark.sameSet(this.marks, marks || Mark.none)\n};\n\n// :: (?Fragment) → Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\nNode.prototype.copy = function copy (content) {\n    if ( content === void 0 ) content = null;\n\n  if (content == this.content) { return this }\n  return new this.constructor(this.type, this.attrs, content, this.marks)\n};\n\n// :: ([Mark]) → Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\nNode.prototype.mark = function mark (marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n};\n\n// :: (number, ?number) → Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\nNode.prototype.cut = function cut (from, to) {\n  if (from == 0 && to == this.content.size) { return this }\n  return this.copy(this.content.cut(from, to))\n};\n\n// :: (number, ?number) → Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\nNode.prototype.slice = function slice (from, to, includeParents) {\n    if ( to === void 0 ) to = this.content.size;\n    if ( includeParents === void 0 ) includeParents = false;\n\n  if (from == to) { return Slice.empty }\n\n  var $from = this.resolve(from), $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth), node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth)\n};\n\n// :: (number, number, Slice) → Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\nNode.prototype.replace = function replace$1 (from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice)\n};\n\n// :: (number) → ?Node\n// Find the node directly after the given position.\nNode.prototype.nodeAt = function nodeAt (pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n      var index = ref.index;\n      var offset = ref.offset;\n    node = node.maybeChild(index);\n    if (!node) { return null }\n    if (offset == pos || node.isText) { return node }\n    pos -= offset + 1;\n  }\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childAfter = function childAfter (pos) {\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  return {node: this.content.maybeChild(index), index: index, offset: offset}\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childBefore = function childBefore (pos) {\n  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n  var node = this.content.child(index - 1);\n  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n};\n\n// :: (number) → ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\nNode.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };\n\nNode.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };\n\n// :: (number, number, union<Mark, MarkType>) → bool\n// Test whether a given mark or mark type occurs in this document\n// between the two given positions.\nNode.prototype.rangeHasMark = function rangeHasMark (from, to, type) {\n  var found = false;\n  if (to > from) { this.nodesBetween(from, to, function (node) {\n    if (type.isInSet(node.marks)) { found = true; }\n    return !found\n  }); }\n  return found\n};\n\n// :: bool\n// True when this is a block (non-inline node)\nprototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };\n\n// :: bool\n// True when this is a textblock node, a block node with inline\n// content.\nprototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };\n\n// :: bool\n// True when this node allows inline content.\nprototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };\n\n// :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\nprototypeAccessors$3.isInline.get = function () { return this.type.isInline };\n\n// :: bool\n// True when this is a text node.\nprototypeAccessors$3.isText.get = function () { return this.type.isText };\n\n// :: bool\n// True when this is a leaf node.\nprototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };\n\n// :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\nprototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };\n\n// :: () → string\n// Return a string representation of this node for debugging\n// purposes.\nNode.prototype.toString = function toString () {\n  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n  var name = this.type.name;\n  if (this.content.size)\n    { name += \"(\" + this.content.toStringInner() + \")\"; }\n  return wrapMarks(this.marks, name)\n};\n\n// :: (number) → ContentMatch\n// Get the content match in this node at the given index.\nNode.prototype.contentMatchAt = function contentMatchAt (index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n  if (!match) { throw new Error(\"Called contentMatchAt on a node with invalid content\") }\n  return match\n};\n\n// :: (number, number, ?Fragment, ?number, ?number) → bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\nNode.prototype.canReplace = function canReplace (from, to, replacement, start, end) {\n    if ( replacement === void 0 ) replacement = Fragment.empty;\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = replacement.childCount;\n\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n  if (!two || !two.validEnd) { return false }\n  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (number, number, NodeType, ?[Mark]) → bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\nNode.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) { return false }\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false\n};\n\n// :: (Node) → bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\nNode.prototype.canAppend = function canAppend (other) {\n  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n  else { return this.type.compatibleContent(other.type) }\n};\n\n// :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\nNode.prototype.check = function check () {\n  if (!this.type.validContent(this.content))\n    { throw new RangeError((\"Invalid content for node \" + (this.type.name) + \": \" + (this.content.toString().slice(0, 50)))) }\n  var copy = Mark.none;\n  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }\n  if (!Mark.sameSet(copy, this.marks))\n    { throw new RangeError((\"Invalid collection of marks for node \" + (this.type.name) + \": \" + (this.marks.map(function (m) { return m.type.name; })))) }\n  this.content.forEach(function (node) { return node.check(); });\n};\n\n// :: () → Object\n// Return a JSON-serializeable representation of this node.\nNode.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  if (this.content.size)\n    { obj.content = this.content.toJSON(); }\n  if (this.marks.length)\n    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }\n  return obj\n};\n\n// :: (Schema, Object) → Node\n// Deserialize a node from its JSON representation.\nNode.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Node.fromJSON\") }\n  var marks = null;\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) { throw new RangeError(\"Invalid mark data for Node.fromJSON\") }\n    marks = json.marks.map(schema.markFromJSON);\n  }\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") { throw new RangeError(\"Invalid text node in JSON\") }\n    return schema.text(json.text, marks)\n  }\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks)\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors$3 );\n\nvar TextNode = /*@__PURE__*/(function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks);\n\n    if (!content) { throw new RangeError(\"Empty text nodes are not allowed\") }\n\n    this.text = content;\n  }\n\n  if ( Node ) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create( Node && Node.prototype );\n  TextNode.prototype.constructor = TextNode;\n\n  var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };\n\n  TextNode.prototype.toString = function toString () {\n    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  };\n\n  prototypeAccessors$1.textContent.get = function () { return this.text };\n\n  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };\n\n  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };\n\n  TextNode.prototype.mark = function mark (marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  };\n\n  TextNode.prototype.withText = function withText (text) {\n    if (text == this.text) { return this }\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  };\n\n  TextNode.prototype.cut = function cut (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) { return this }\n    return this.withText(this.text.slice(from, to))\n  };\n\n  TextNode.prototype.eq = function eq (other) {\n    return this.sameMarkup(other) && this.text == other.text\n  };\n\n  TextNode.prototype.toJSON = function toJSON () {\n    var base = Node.prototype.toJSON.call(this);\n    base.text = this.text;\n    return base\n  };\n\n  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );\n\n  return TextNode;\n}(Node));\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--)\n    { str = marks[i].type.name + \"(\" + str + \")\"; }\n  return str\n}\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };\n\nContentMatch.parse = function parse (string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n  if (stream.next == null) { return ContentMatch.empty }\n  var expr = parseExpr(stream);\n  if (stream.next) { stream.err(\"Unexpected trailing text\"); }\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match\n};\n\n// :: (NodeType) → ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\nContentMatch.prototype.matchType = function matchType (type) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { if (this.next[i] == type) { return this.next[i + 1] } }\n  return null\n};\n\n// :: (Fragment, ?number, ?number) → ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\nContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = frag.childCount;\n\n  var cur = this;\n  for (var i = start; cur && i < end; i++)\n    { cur = cur.matchType(frag.child(i).type); }\n  return cur\n};\n\nprototypeAccessors$4.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false\n};\n\n// :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\nprototypeAccessors$4.defaultType.get = function () {\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this.next[i];\n    if (!(type.isText || type.hasRequiredAttrs())) { return type }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible (other) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { for (var j = 0; j < other.next.length; j += 2)\n      { if (this.next[i] == other.next[j]) { return true } } }\n  return false\n};\n\n// :: (Fragment, bool, ?number) → ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\nContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {\n    if ( toEnd === void 0 ) toEnd = false;\n    if ( startIndex === void 0 ) startIndex = 0;\n\n  var seen = [this];\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n    if (finished && (!toEnd || finished.validEnd))\n      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i], next = match.next[i + 1];\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n        if (found) { return found }\n      }\n    }\n  }\n\n  return search(this, [])\n};\n\n// :: (NodeType) → ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\nContentMatch.prototype.findWrapping = function findWrapping (target) {\n  for (var i = 0; i < this.wrapCache.length; i += 2)\n    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping (target) {\n  var seen = Object.create(null), active = [{match: this, type: null, via: null}];\n  while (active.length) {\n    var current = active.shift(), match = current.match;\n    if (match.matchType(target)) {\n      var result = [];\n      for (var obj = current; obj.type; obj = obj.via)\n        { result.push(obj.type); }\n      return result.reverse()\n    }\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({match: type.contentMatch, type: type, via: current});\n        seen[type.name] = true;\n      }\n    }\n  }\n};\n\n// :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\nprototypeAccessors$4.edgeCount.get = function () {\n  return this.next.length >> 1\n};\n\n// :: (number) → {type: NodeType, next: ContentMatch}\n// Get the _n_​th outgoing edge from this node in the finite\n// automaton that describes the content expression.\nContentMatch.prototype.edge = function edge (n) {\n  var i = n << 1;\n  if (i >= this.next.length) { throw new RangeError((\"There's no \" + n + \"th edge in this content match\")) }\n  return {type: this.next[i], next: this.next[i + 1]}\n};\n\nContentMatch.prototype.toString = function toString () {\n  var seen = [];\n  function scan(m) {\n    seen.push(m);\n    for (var i = 1; i < m.next.length; i += 2)\n      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }\n  }\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)\n      { out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]); }\n    return out\n  }).join(\"\\n\")\n};\n\nObject.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );\n\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n  if (this.tokens[this.tokens.length - 1] == \"\") { this.tokens.pop(); }\n  if (this.tokens[0] == \"\") { this.tokens.shift(); }\n};\n\nvar prototypeAccessors$1$2 = { next: { configurable: true } };\n\nprototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };\n\nTokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };\n\nTokenStream.prototype.err = function err (str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") };\n\nObject.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );\n\nfunction parseExpr(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSeq(stream)); }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSubscript(stream)); }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs: exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\"))\n      { expr = {type: \"plus\", expr: expr}; }\n    else if (stream.eat(\"*\"))\n      { expr = {type: \"star\", expr: expr}; }\n    else if (stream.eat(\"?\"))\n      { expr = {type: \"opt\", expr: expr}; }\n    else if (stream.eat(\"{\"))\n      { expr = parseExprRange(stream, expr); }\n    else { break }\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) { stream.err(\"Expected number, got '\" + stream.next + \"'\"); }\n  var result = Number(stream.next);\n  stream.pos++;\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") { max = parseNum(stream); }\n    else { max = -1; }\n  }\n  if (!stream.eat(\"}\")) { stream.err(\"Unclosed braced range\"); }\n  return {type: \"range\", min: min, max: max, expr: expr}\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes, type = types[name];\n  if (type) { return [type] }\n  var result = [];\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }\n  }\n  if (result.length == 0) { stream.err(\"No node type or group '\" + name + \"' found\"); }\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) { stream.err(\"Missing closing paren\"); }\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) { stream.inline = type.isInline; }\n      else if (stream.inline != type.isInline) { stream.err(\"Mixing inline and block content\"); }\n      return {type: \"name\", value: type}\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    var edge = {term: term, to: to};\n    nfa[from].push(edge);\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) { return next }\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp)\n\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n      if (!term && result.indexOf(to) == -1) { scan(to); }\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) { return }\n        var known = out.indexOf(term), set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) { out.push(term, set = []); }\n          if (set.indexOf(node) == -1) { set.push(node); }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i], dead = !state.validEnd, nodes = [];\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j], next = state.next[j + 1];\n      nodes.push(node.name);\n      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }\n      if (work.indexOf(next) == -1) { work.push(next); }\n    }\n    if (dead) { stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\"); }\n  }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) { return null }\n    defaults[attrName] = attr.default;\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) { given = attr.default; }\n      else { throw new RangeError(\"No value supplied for attribute \" + name) }\n    }\n    built[name] = given;\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name;\n\n  // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n  this.schema = schema;\n\n  // :: NodeSpec\n  // The spec that this type is based on\n  this.spec = spec;\n\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n\n  this.defaultAttrs = defaultAttrs(this.attrs);\n\n  // :: ContentMatch\n  // The starting match of the node type's content expression.\n  this.contentMatch = null;\n\n  // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n  this.markSet = null;\n\n  // :: bool\n  // True if this node type has inline content.\n  this.inlineContent = null;\n\n  // :: bool\n  // True if this is a block type\n  this.isBlock = !(spec.inline || name == \"text\");\n\n  // :: bool\n  // True if this is the text node type.\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// :: bool\n// True if this is an inline type.\nprototypeAccessors$5.isInline.get = function () { return !this.isBlock };\n\n// :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\nprototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };\n\n// :: bool\n// True for node types that allow no content.\nprototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };\n\n// :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\nprototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };\n\n// :: () → bool\n// Tells you whether this node type has any required attributes.\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {\n  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }\n  return false\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent (other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch)\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {\n  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n  else { return computeAttrs(this.attrs, attrs) }\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\nNodeType.prototype.create = function create (attrs, content, marks) {\n  if (this.isText) { throw new Error(\"NodeType.create can't construct text nodes\") }\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\nNodeType.prototype.createChecked = function createChecked (attrs, content, marks) {\n  content = Fragment.from(content);\n  if (!this.validContent(content))\n    { throw new RangeError(\"Invalid content for node \" + this.name) }\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\nNodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n    if (!before) { return null }\n    content = before.append(content);\n  }\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n  if (!after) { return null }\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n};\n\n// :: (Fragment) → bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\nNodeType.prototype.validContent = function validContent (content) {\n  var result = this.contentMatch.matchFragment(content);\n  if (!result || !result.validEnd) { return false }\n  for (var i = 0; i < content.childCount; i++)\n    { if (!this.allowsMarks(content.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (MarkType) → bool\n// Check whether the given mark type is allowed in this node.\nNodeType.prototype.allowsMarkType = function allowsMarkType (markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1\n};\n\n// :: ([Mark]) → bool\n// Test whether the given set of marks are allowed in this node.\nNodeType.prototype.allowsMarks = function allowsMarks (marks) {\n  if (this.markSet == null) { return true }\n  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }\n  return true\n};\n\n// :: ([Mark]) → [Mark]\n// Removes the marks that are not allowed in this node from the given set.\nNodeType.prototype.allowedMarks = function allowedMarks (marks) {\n  if (this.markSet == null) { return marks }\n  var copy;\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      if (!copy) { copy = marks.slice(0, i); }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n  return !copy ? marks : copy.length ? copy : Mark.empty\n};\n\nNodeType.compile = function compile (nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });\n\n  var topType = schema.spec.topNode || \"doc\";\n  if (!result[topType]) { throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\") }\n  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n  for (var _ in result.text.attrs) { throw new RangeError(\"The text node type should not have attributes\") }\n\n  return result\n};\n\nObject.defineProperties( NodeType.prototype, prototypeAccessors$5 );\n\n// Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$3 = { isRequired: { configurable: true } };\n\nprototypeAccessors$1$3.isRequired.get = function () {\n  return !this.hasDefault\n};\n\nObject.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name;\n\n  // :: Schema\n  // The schema that this mark type instance is part of.\n  this.schema = schema;\n\n  // :: MarkSpec\n  // The spec on which the type is based.\n  this.spec = spec;\n\n  this.attrs = initAttrs(spec.attrs);\n\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n};\n\n// :: (?Object) → Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\nMarkType.prototype.create = function create (attrs) {\n  if (!attrs && this.instance) { return this.instance }\n  return new Mark(this, computeAttrs(this.attrs, attrs))\n};\n\nMarkType.compile = function compile (marks, schema) {\n  var result = Object.create(null), rank = 0;\n  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });\n  return result\n};\n\n// :: ([Mark]) → [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\nMarkType.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {\n    set = set.slice(0, i).concat(set.slice(i + 1));\n    i--;\n  } }\n  return set\n};\n\n// :: ([Mark]) → ?Mark\n// Tests whether there is a mark of this type in the given set.\nMarkType.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this) { return set[i] } }\n};\n\n// :: (MarkType) → bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\nMarkType.prototype.excludes = function excludes (other) {\n  return this.excluded.indexOf(other) > -1\n};\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nvar Schema = function Schema(spec) {\n  // :: SchemaSpec\n  // The [spec](#model.SchemaSpec) on which the schema is based,\n  // with the added guarantee that its `nodes` and `marks`\n  // properties are\n  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n  // (not raw objects).\n  this.spec = {};\n  for (var prop in spec) { this.spec[prop] = spec[prop]; }\n  this.spec.nodes = OrderedMap.from(spec.nodes);\n  this.spec.marks = OrderedMap.from(spec.marks);\n\n  // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n  this.nodes = NodeType.compile(this.spec.nodes, this);\n\n  // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n  this.marks = MarkType.compile(this.spec.marks, this);\n\n  var contentExprCache = Object.create(null);\n  for (var prop$1 in this.nodes) {\n    if (prop$1 in this.marks)\n      { throw new RangeError(prop$1 + \" can not be both a node and a mark\") }\n    var type = this.nodes[prop$1], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n    type.contentMatch = contentExprCache[contentExpr] ||\n      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n    type.inlineContent = type.contentMatch.inlineContent;\n    type.markSet = markExpr == \"_\" ? null :\n      markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n      markExpr == \"\" || !type.inlineContent ? [] : null;\n  }\n  for (var prop$2 in this.marks) {\n    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;\n    type$1.excluded = excl == null ? [type$1] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n  }\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this);\n  this.markFromJSON = this.markFromJSON.bind(this);\n\n  // :: NodeType\n  // The type of the [default top node](#model.SchemaSpec.topNode)\n  // for this schema.\n  this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n\n  // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n  this.cached = Object.create(null);\n  this.cached.wrappings = Object.create(null);\n};\n\n// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\nSchema.prototype.node = function node (type, attrs, content, marks) {\n  if (typeof type == \"string\")\n    { type = this.nodeType(type); }\n  else if (!(type instanceof NodeType))\n    { throw new RangeError(\"Invalid node type: \" + type) }\n  else if (type.schema != this)\n    { throw new RangeError(\"Node type from different schema used (\" + type.name + \")\") }\n\n  return type.createChecked(attrs, content, marks)\n};\n\n// :: (string, ?[Mark]) → Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\nSchema.prototype.text = function text (text$1, marks) {\n  var type = this.nodes.text;\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))\n};\n\n// :: (union<string, MarkType>, ?Object) → Mark\n// Create a mark with the given type and attributes.\nSchema.prototype.mark = function mark (type, attrs) {\n  if (typeof type == \"string\") { type = this.marks[type]; }\n  return type.create(attrs)\n};\n\n// :: (Object) → Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\nSchema.prototype.nodeFromJSON = function nodeFromJSON (json) {\n  return Node.fromJSON(this, json)\n};\n\n// :: (Object) → Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\nSchema.prototype.markFromJSON = function markFromJSON (json) {\n  return Mark.fromJSON(this, json)\n};\n\nSchema.prototype.nodeType = function nodeType (name) {\n  var found = this.nodes[name];\n  if (!found) { throw new RangeError(\"Unknown node type: \" + name) }\n  return found\n};\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i], mark = schema.marks[name], ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var mark$1 = schema.marks[prop];\n        if (name == \"_\" || (mark$1.spec.group && mark$1.spec.group.split(\" \").indexOf(name) > -1))\n          { found.push(ok = mark$1); }\n      }\n    }\n    if (!ok) { throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\") }\n  }\n  return found\n}\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nvar DOMParser = function DOMParser(schema, rules) {\n  var this$1 = this;\n\n  // :: Schema\n  // The schema into which the parser parses.\n  this.schema = schema;\n  // :: [ParseRule]\n  // The set of [parse rules](#model.ParseRule) that the parser\n  // uses, in order of precedence.\n  this.rules = rules;\n  this.tags = [];\n  this.styles = [];\n\n  rules.forEach(function (rule) {\n    if (rule.tag) { this$1.tags.push(rule); }\n    else if (rule.style) { this$1.styles.push(rule); }\n  });\n\n  // Only normalize list elements when lists in the schema can't directly contain themselves\n  this.normalizeLists = !this.tags.some(function (r) {\n    if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) { return false }\n    var node = schema.nodes[r.node];\n    return node.contentMatch.matchType(node)\n  });\n};\n\n// :: (dom.Node, ?ParseOptions) → Node\n// Parse a document from the content of a DOM node.\nDOMParser.prototype.parse = function parse (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, false);\n  context.addAll(dom, null, options.from, options.to);\n  return context.finish()\n};\n\n// :: (dom.Node, ?ParseOptions) → Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\nDOMParser.prototype.parseSlice = function parseSlice (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, true);\n  context.addAll(dom, null, options.from, options.to);\n  return Slice.maxOpen(context.finish())\n};\n\nDOMParser.prototype.matchTag = function matchTag (dom, context, after) {\n  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n    var rule = this.tags[i];\n    if (matches(dom, rule.tag) &&\n        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n        (!rule.context || context.matchesContext(rule.context))) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom);\n        if (result === false) { continue }\n        rule.attrs = result;\n      }\n      return rule\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {\n  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n    var rule = this.styles[i];\n    if (rule.style.indexOf(prop) != 0 ||\n        rule.context && !context.matchesContext(rule.context) ||\n        // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        rule.style.length > prop.length &&\n        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n      { continue }\n    if (rule.getAttrs) {\n      var result = rule.getAttrs(value);\n      if (result === false) { continue }\n      rule.attrs = result;\n    }\n    return rule\n  }\n};\n\n// : (Schema) → [ParseRule]\nDOMParser.schemaRules = function schemaRules (schema) {\n  var result = [];\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority, i = 0;\n    for (; i < result.length; i++) {\n      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n      if (nextPriority < priority) { break }\n    }\n    result.splice(i, 0, rule);\n  }\n\n  var loop = function ( name ) {\n    var rules = schema.marks[name].spec.parseDOM;\n    if (rules) { rules.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.mark = name;\n    }); }\n  };\n\n    for (var name in schema.marks) loop( name );\n  var loop$1 = function ( name ) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM;\n    if (rules$1) { rules$1.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.node = name$1;\n    }); }\n  };\n\n    for (var name$1 in schema.nodes) loop$1();\n  return result\n};\n\n// :: (Schema) → DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n// [priority](#model.ParseRule.priority).\nDOMParser.fromSchema = function fromSchema (schema) {\n  return schema.cached.domParser ||\n    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n};\n\n// : Object<bool> The block-level tags in HTML5\nvar blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\n\n// : Object<bool> The tags that we normally ignore.\nvar ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n};\n\n// : Object<bool> List tags.\nvar listTags = {ol: true, ul: true};\n\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = [];\n  // Marks applied to this node itself\n  this.marks = marks;\n  // Marks applied to its children\n  this.activeMarks = Mark.none;\n  // Marks that can't apply here, but will be used in children if possible\n  this.pendingMarks = pendingMarks;\n  // Nested Marks with same type\n  this.stashMarks = [];\n};\n\nNodeContext.prototype.findWrapping = function findWrapping (node) {\n  if (!this.match) {\n    if (!this.type) { return [] }\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch, wrap;\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap\n      } else {\n        return null\n      }\n    }\n  }\n  return this.match.findWrapping(node.type)\n};\n\nNodeContext.prototype.finish = function finish (openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n    var last = this.content[this.content.length - 1], m;\n    if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) { this.content.pop(); }\n      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }\n    }\n  }\n  var content = Fragment.from(this.content);\n  if (!openEnd && this.match)\n    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content\n};\n\nNodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {\n  for (var i = this.stashMarks.length - 1; i >= 0; i--)\n    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }\n};\n\nNodeContext.prototype.applyPending = function applyPending (nextType) {\n  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n    var mark = pending[i];\n    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n        !mark.isInSet(this.activeMarks)) {\n      this.activeMarks = mark.addToSet(this.activeMarks);\n      this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n    }\n  }\n};\n\nNodeContext.prototype.inlineContext = function inlineContext (node) {\n  if (this.type) { return this.type.inlineContent }\n  if (this.content.length) { return this.content[0].isInline }\n  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser;\n  // : Object The options passed to this parse.\n  this.options = options;\n  this.isOpen = open;\n  var topNode = options.topNode, topContext;\n  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);\n  if (topNode)\n    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                 options.topMatch || topNode.type.contentMatch, topOptions); }\n  else if (open)\n    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }\n  else\n    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }\n  this.nodes = [topContext];\n  // : [Mark] The current set of marks\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open]\n};\n\n// : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\nParseContext.prototype.addDOM = function addDOM (dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;\n    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }\n    this.addElement(dom);\n    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode (dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n  if (top.options & OPT_PRESERVE_WS_FULL ||\n      top.inlineContext(dom) ||\n      /[^ \\t\\r\\n\\u000c]/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n      // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n      if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n        if (!nodeBefore ||\n            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n            (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n          { value = value.slice(1); }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    } else {\n      value = value.replace(/\\r\\n?/g, \"\\n\");\n    }\n    if (value) { this.insertNode(this.parser.schema.text(value)); }\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n};\n\n// : (dom.Element, ?ParseRule)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\nParseContext.prototype.addElement = function addElement (dom, matchAfter) {\n  var name = dom.nodeName.toLowerCase(), ruleID;\n  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }\n  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n      (ruleID = this.parser.matchTag(dom, this, matchAfter));\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n    this.ignoreFallback(dom);\n  } else if (!rule || rule.skip || rule.closeParent) {\n    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }\n    else if (rule && rule.skip.nodeType) { dom = rule.skip; }\n    var sync, top = this.top, oldNeedsBlock = this.needsBlock;\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n      if (!top.type) { this.needsBlock = true; }\n    } else if (!dom.firstChild) {\n      this.leafFallback(dom);\n      return\n    }\n    this.addAll(dom);\n    if (sync) { this.sync(top); }\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);\n  }\n};\n\n// Called for leaf DOM nodes that would otherwise be ignored\nParseContext.prototype.leafFallback = function leafFallback (dom) {\n  if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n    { this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\")); }\n};\n\n// Called for ignored nodes\nParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {\n  // Ignored BR nodes should at least create an inline context\n  if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n    { this.findPlace(this.parser.schema.text(\"-\")); }\n};\n\n// Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\nParseContext.prototype.readStyles = function readStyles (styles) {\n  var marks = Mark.none;\n  style: for (var i = 0; i < styles.length; i += 2) {\n    for (var after = null;;) {\n      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n      if (!rule) { continue style }\n      if (rule.ignore) { return null }\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n      if (rule.consuming === false) { after = rule; }\n      else { break }\n    }\n  }\n  return marks\n};\n\n// : (dom.Element, ParseRule) → bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\nParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {\n    var this$1 = this;\n\n  var sync, nodeType, markType, mark;\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n    if (!nodeType.isLeaf) {\n      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);\n    } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n      this.leafFallback(dom);\n    }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (continueAfter) {\n    this.addElement(dom, continueAfter);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });\n  } else {\n    var contentDOM = rule.contentElement;\n    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM); }\n    else if (typeof contentDOM == \"function\") { contentDOM = contentDOM(dom); }\n    if (!contentDOM) { contentDOM = dom; }\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n  if (sync) { this.sync(startIn); this.open--; }\n  if (mark) { this.removePendingMark(mark, startIn); }\n};\n\n// : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\nParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {\n  var index = startIndex || 0;\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n           end = endIndex == null ? null : parent.childNodes[endIndex];\n       dom != end; dom = dom.nextSibling, ++index) {\n    this.findAtPoint(parent, index);\n    this.addDOM(dom);\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n      { this.sync(sync); }\n  }\n  this.findAtPoint(parent, index);\n};\n\n// Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\nParseContext.prototype.findPlace = function findPlace (node) {\n  var route, sync;\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this.nodes[depth];\n    var found = cx.findWrapping(node);\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n      if (!found.length) { break }\n    }\n    if (cx.solid) { break }\n  }\n  if (!route) { return false }\n  this.sync(sync);\n  for (var i = 0; i < route.length; i++)\n    { this.enterInner(route[i], null, false); }\n  return true\n};\n\n// : (Node) → ?Node\n// Try to insert the given node, adjusting the context when needed.\nParseContext.prototype.insertNode = function insertNode (node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n    if (block) { this.enterInner(block); }\n  }\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    top.applyPending(node.type);\n    if (top.match) { top.match = top.match.matchType(node.type); }\n    var marks = top.activeMarks;\n    for (var i = 0; i < node.marks.length; i++)\n      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n        { marks = node.marks[i].addToSet(marks); } }\n    top.content.push(node.mark(marks));\n    return true\n  }\n  return false\n};\n\n// : (NodeType, ?Object) → bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\nParseContext.prototype.enter = function enter (type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n  if (ok) { this.enterInner(type, attrs, true, preserveWS); }\n  return ok\n};\n\n// Open a node of the given type\nParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.applyPending(type);\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);\n  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n  this.open++;\n};\n\n// Make sure all nodes above this.open are finished and added to\n// their parents\nParseContext.prototype.closeExtra = function closeExtra (openEnd) {\n  var i = this.nodes.length - 1;\n  if (i > this.open) {\n    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish () {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n};\n\nParseContext.prototype.sync = function sync (to) {\n  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {\n    this.open = i;\n    return\n  } }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n  this.closeExtra();\n  var pos = 0;\n  for (var i = this.open; i >= 0; i--) {\n    var content = this.nodes[i].content;\n    for (var j = content.length - 1; j >= 0; j--)\n      { pos += content[j].nodeSize; }\n    if (i) { pos++; }\n  }\n  return pos\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == parent && this.find[i].offset == offset)\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findInside = function findInside (parent) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findAround = function findAround (parent, content, before) {\n  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n      var pos = content.compareDocumentPosition(this.find[i].node);\n      if (pos & (before ? 2 : 4))\n        { this.find[i].pos = this.currentPos; }\n    }\n  } }\n};\n\nParseContext.prototype.findInText = function findInText (textNode) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == textNode)\n      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }\n  } }\n};\n\n// : (string) → bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\nParseContext.prototype.matchesContext = function matchesContext (context) {\n    var this$1 = this;\n\n  if (context.indexOf(\"|\") > -1)\n    { return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this) }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) { continue }\n        for (; depth >= minDepth; depth--)\n          { if (match(i - 1, depth)) { return true } }\n        return false\n      } else {\n        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type\n            : option && depth >= minDepth ? option.node(depth - minDepth).type\n            : null;\n        if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n          { return false }\n        depth--;\n      }\n    }\n    return true\n  };\n  return match(parts.length - 1, this.open)\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext () {\n  var $context = this.options.context;\n  if ($context) { for (var d = $context.depth; d >= 0; d--) {\n    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }\n  } }\n  for (var name in this.parser.schema.nodes) {\n    var type = this.parser.schema.nodes[name];\n    if (type.isTextblock && type.defaultAttrs) { return type }\n  }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark (mark) {\n  var found = findSameMarkInSet(mark, this.top.pendingMarks);\n  if (found) { this.top.stashMarks.push(found); }\n  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {\n  for (var depth = this.open; depth >= 0; depth--) {\n    var level = this.nodes[depth];\n    var found = level.pendingMarks.lastIndexOf(mark);\n    if (found > -1) {\n      level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n    } else {\n      level.activeMarks = mark.removeFromSet(level.activeMarks);\n      var stashMark = level.popFromStashMark(mark);\n      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n        { level.activeMarks = stashMark.addToSet(level.activeMarks); }\n    }\n    if (level == upto) { break }\n  }\n};\n\nObject.defineProperties( ParseContext.prototype, prototypeAccessors$6 );\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }\n  return result\n}\n\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var loop = function ( name ) {\n    var parent = nodes[name];\n    if (!parent.allowsMarkType(markType)) { return }\n    var seen = [], scan = function (match) {\n      seen.push(match);\n      for (var i = 0; i < match.edgeCount; i++) {\n        var ref = match.edge(i);\n        var type = ref.type;\n        var next = ref.next;\n        if (type == nodeType) { return true }\n        if (seen.indexOf(next) < 0 && scan(next)) { return true }\n      }\n    };\n    if (scan(parent.contentMatch)) { return { v: true } }\n  };\n\n  for (var name in nodes) {\n    var returned = loop( name );\n\n    if ( returned ) return returned.v;\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (var i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) { return set[i] }\n  }\n}\n\n// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nvar DOMSerializer = function DOMSerializer(nodes, marks) {\n  // :: Object<(node: Node) → DOMOutputSpec>\n  // The node serialization functions.\n  this.nodes = nodes || {};\n  // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n  // The mark serialization functions.\n  this.marks = marks || {};\n};\n\n// :: (Fragment, ?Object) → dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serializer can create\n// nodes.\nDOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  if (!target) { target = doc(options).createDocumentFragment(); }\n\n  var top = target, active = null;\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) { active = []; }\n      var keep = 0, rendered = 0;\n      while (keep < active.length && rendered < node.marks.length) {\n        var next = node.marks[rendered];\n        if (!this$1.marks[next.type.name]) { rendered++; continue }\n        if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }\n        keep += 2; rendered++;\n      }\n      while (keep < active.length) {\n        top = active.pop();\n        active.pop();\n      }\n      while (rendered < node.marks.length) {\n        var add = node.marks[rendered++];\n        var markDOM = this$1.serializeMark(add, node.isInline, options);\n        if (markDOM) {\n          active.push(add, top);\n          top.appendChild(markDOM.dom);\n          top = markDOM.contentDOM || markDOM.dom;\n        }\n      }\n    }\n    top.appendChild(this$1.serializeNodeInner(node, options));\n  });\n\n  return target\n};\n\nDOMSerializer.prototype.serializeNodeInner = function serializeNodeInner (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var ref =\n      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n    var dom = ref.dom;\n    var contentDOM = ref.contentDOM;\n  if (contentDOM) {\n    if (node.isLeaf)\n      { throw new RangeError(\"Content hole not allowed in a leaf node spec\") }\n    if (options.onContent)\n      { options.onContent(node, contentDOM, options); }\n    else\n      { this.serializeFragment(node.content, options, contentDOM); }\n  }\n  return dom\n};\n\n// :: (Node, ?Object) → dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [content](#model.Node.content).\nDOMSerializer.prototype.serializeNode = function serializeNode (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var dom = this.serializeNodeInner(node, options);\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n    if (wrap) {\n(wrap.contentDOM || wrap.dom).appendChild(dom);\n      dom = wrap.dom;\n    }\n  }\n  return dom\n};\n\nDOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {\n    if ( options === void 0 ) options = {};\n\n  var toDOM = this.marks[mark.type.name];\n  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n};\n\n// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n// the spec has a hole (zero) in it, `contentDOM` will point at the\n// node with the hole.\nDOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {\n    if ( xmlNS === void 0 ) xmlNS = null;\n\n  if (typeof structure == \"string\")\n    { return {dom: doc.createTextNode(structure)} }\n  if (structure.nodeType != null)\n    { return {dom: structure} }\n  if (structure.dom && structure.dom.nodeType != null)\n    { return structure }\n  var tagName = structure[0], space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1], start = 1;\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) { if (attrs[name] != null) {\n      var space$1 = name.indexOf(\" \");\n      if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }\n      else { dom.setAttribute(name, attrs[name]); }\n    } }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start)\n        { throw new RangeError(\"Content hole must be the only child of its parent node\") }\n      return {dom: dom, contentDOM: dom}\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);\n        var inner = ref.dom;\n        var innerContent = ref.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) { throw new RangeError(\"Multiple content holes\") }\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {dom: dom, contentDOM: contentDOM}\n};\n\n// :: (Schema) → DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\nDOMSerializer.fromSchema = function fromSchema (schema) {\n  return schema.cached.domSerializer ||\n    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n};\n\n// : (Schema) → Object<(node: Node) → DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\nDOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {\n  var result = gatherToDOM(schema.nodes);\n  if (!result.text) { result.text = function (node) { return node.text; }; }\n  return result\n};\n\n// : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\nDOMSerializer.marksFromSchema = function marksFromSchema (schema) {\n  return gatherToDOM(schema.marks)\n};\n\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) { result[name] = toDOM; }\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n\nexport { ContentMatch, DOMParser, DOMSerializer, Fragment, Mark, MarkType, Node, NodeRange, NodeType, ReplaceError, ResolvedPos, Schema, Slice };\n//# sourceMappingURL=index.es.js.map\n","import { Slice, Fragment, Mark, Node } from 'prosemirror-model';\nimport { ReplaceStep, ReplaceAroundStep, Transform } from 'prosemirror-transform';\n\nvar classesById = Object.create(null);\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nvar Selection = function Selection($anchor, $head, ranges) {\n  // :: [SelectionRange]\n  // The ranges covered by the selection.\n  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  // :: ResolvedPos\n  // The resolved anchor of the selection (the side that stays in\n  // place when the selection is modified).\n  this.$anchor = $anchor;\n  // :: ResolvedPos\n  // The resolved head of the selection (the side that moves when\n  // the selection is modified).\n  this.$head = $head;\n};\n\nvar prototypeAccessors = { anchor: { configurable: true },head: { configurable: true },from: { configurable: true },to: { configurable: true },$from: { configurable: true },$to: { configurable: true },empty: { configurable: true } };\n\n// :: number\n// The selection's anchor, as an unresolved position.\nprototypeAccessors.anchor.get = function () { return this.$anchor.pos };\n\n// :: number\n// The selection's head.\nprototypeAccessors.head.get = function () { return this.$head.pos };\n\n// :: number\n// The lower bound of the selection's main range.\nprototypeAccessors.from.get = function () { return this.$from.pos };\n\n// :: number\n// The upper bound of the selection's main range.\nprototypeAccessors.to.get = function () { return this.$to.pos };\n\n// :: ResolvedPos\n// The resolved lowerbound of the selection's main range.\nprototypeAccessors.$from.get = function () {\n  return this.ranges[0].$from\n};\n\n// :: ResolvedPos\n// The resolved upper bound of the selection's main range.\nprototypeAccessors.$to.get = function () {\n  return this.ranges[0].$to\n};\n\n// :: bool\n// Indicates whether the selection contains any content.\nprototypeAccessors.empty.get = function () {\n  var ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++)\n    { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }\n  return true\n};\n\n// eq:: (Selection) → bool\n// Test whether the selection is the same as another selection.\n\n// map:: (doc: Node, mapping: Mappable) → Selection\n// Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n// should be the new document to which we are mapping.\n\n// :: () → Slice\n// Get the content of this selection as a slice.\nSelection.prototype.content = function content () {\n  return this.$from.node(0).slice(this.from, this.to, true)\n};\n\n// :: (Transaction, ?Slice)\n// Replace the selection with a slice or, if no slice is given,\n// delete the selection. Will append to the given transaction.\nSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n  // Put the new selection at the position after the inserted\n  // content. When that ended in an inline node, search backwards,\n  // to get the position after that node. If not, search forward.\n  var lastNode = content.content.lastChild, lastParent = null;\n  for (var i = 0; i < content.openEnd; i++) {\n    lastParent = lastNode;\n    lastNode = lastNode.lastChild;\n  }\n\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n    var ref = ranges[i$1];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content);\n    if (i$1 == 0)\n      { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }\n  }\n};\n\n// :: (Transaction, Node)\n// Replace the selection with the given node, appending the changes\n// to the given transaction.\nSelection.prototype.replaceWith = function replaceWith (tr, node) {\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++) {\n    var ref = ranges[i];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    var from = mapping.map($from.pos), to = mapping.map($to.pos);\n    if (i) {\n      tr.deleteRange(from, to);\n    } else {\n      tr.replaceRangeWith(from, to, node);\n      selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n    }\n  }\n};\n\n// toJSON:: () → Object\n// Convert the selection to a JSON representation. When implementing\n// this for a custom selection class, make sure to give the object a\n// `type` property whose value matches the ID under which you\n// [registered](#state.Selection^jsonID) your class.\n\n// :: (ResolvedPos, number, ?bool) → ?Selection\n// Find a valid cursor or leaf node selection starting at the given\n// position and searching back if `dir` is negative, and forward if\n// positive. When `textOnly` is true, only consider cursor\n// selections. Will return null when no valid selection position is\n// found.\nSelection.findFrom = function findFrom ($pos, dir, textOnly) {\n  var inner = $pos.parent.inlineContent ? new TextSelection($pos)\n      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n  if (inner) { return inner }\n\n  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n    var found = dir < 0\n        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n    if (found) { return found }\n  }\n};\n\n// :: (ResolvedPos, ?number) → Selection\n// Find a valid cursor or leaf node selection near the given\n// position. Searches forward first by default, but if `bias` is\n// negative, it will search backwards first.\nSelection.near = function near ($pos, bias) {\n    if ( bias === void 0 ) bias = 1;\n\n  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the start of\n// the given document. Will return an\n// [`AllSelection`](#state.AllSelection) if no valid position\n// exists.\nSelection.atStart = function atStart (doc) {\n  return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the end of the\n// given document.\nSelection.atEnd = function atEnd (doc) {\n  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n};\n\n// :: (Node, Object) → Selection\n// Deserialize the JSON representation of a selection. Must be\n// implemented for custom classes (as a static class method).\nSelection.fromJSON = function fromJSON (doc, json) {\n  if (!json || !json.type) { throw new RangeError(\"Invalid input for Selection.fromJSON\") }\n  var cls = classesById[json.type];\n  if (!cls) { throw new RangeError((\"No selection type \" + (json.type) + \" defined\")) }\n  return cls.fromJSON(doc, json)\n};\n\n// :: (string, constructor<Selection>)\n// To be able to deserialize selections from JSON, custom selection\n// classes must register themselves with an ID string, so that they\n// can be disambiguated. Try to pick something that's unlikely to\n// clash with classes from other modules.\nSelection.jsonID = function jsonID (id, selectionClass) {\n  if (id in classesById) { throw new RangeError(\"Duplicate use of selection JSON ID \" + id) }\n  classesById[id] = selectionClass;\n  selectionClass.prototype.jsonID = id;\n  return selectionClass\n};\n\n// :: () → SelectionBookmark\n// Get a [bookmark](#state.SelectionBookmark) for this selection,\n// which is a value that can be mapped without having access to a\n// current document, and later resolved to a real selection for a\n// given document again. (This is used mostly by the history to\n// track and restore old selections.) The default implementation of\n// this method just converts the selection to a text selection and\n// returns the bookmark for that.\nSelection.prototype.getBookmark = function getBookmark () {\n  return TextSelection.between(this.$anchor, this.$head).getBookmark()\n};\n\nObject.defineProperties( Selection.prototype, prototypeAccessors );\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true;\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nvar SelectionRange = function SelectionRange($from, $to) {\n  // :: ResolvedPos\n  // The lower bound of the range.\n  this.$from = $from;\n  // :: ResolvedPos\n  // The upper bound of the range.\n  this.$to = $to;\n};\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nvar TextSelection = /*@__PURE__*/(function (Selection) {\n  function TextSelection($anchor, $head) {\n    if ( $head === void 0 ) $head = $anchor;\n\n    Selection.call(this, $anchor, $head);\n  }\n\n  if ( Selection ) TextSelection.__proto__ = Selection;\n  TextSelection.prototype = Object.create( Selection && Selection.prototype );\n  TextSelection.prototype.constructor = TextSelection;\n\n  var prototypeAccessors$1 = { $cursor: { configurable: true } };\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };\n\n  TextSelection.prototype.map = function map (doc, mapping) {\n    var $head = doc.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent) { return Selection.near($head) }\n    var $anchor = doc.resolve(mapping.map(this.anchor));\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  };\n\n  TextSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    Selection.prototype.replace.call(this, tr, content);\n    if (content == Slice.empty) {\n      var marks = this.$from.marksAcross(this.$to);\n      if (marks) { tr.ensureMarks(marks); }\n    }\n  };\n\n  TextSelection.prototype.eq = function eq (other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  };\n\n  TextSelection.prototype.getBookmark = function getBookmark () {\n    return new TextBookmark(this.anchor, this.head)\n  };\n\n  TextSelection.prototype.toJSON = function toJSON () {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  };\n\n  TextSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      { throw new RangeError(\"Invalid input for TextSelection.fromJSON\") }\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  };\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  TextSelection.create = function create (doc, anchor, head) {\n    if ( head === void 0 ) head = anchor;\n\n    var $anchor = doc.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  };\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  TextSelection.between = function between ($anchor, $head, bias) {\n    var dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }\n    if (!$head.parent.inlineContent) {\n      var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found) { $head = found.$head; }\n      else { return Selection.near($head, bias) }\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }\n      }\n    }\n    return new TextSelection($anchor, $head)\n  };\n\n  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );\n\n  return TextSelection;\n}(Selection));\n\nSelection.jsonID(\"text\", TextSelection);\n\nvar TextBookmark = function TextBookmark(anchor, head) {\n  this.anchor = anchor;\n  this.head = head;\n};\nTextBookmark.prototype.map = function map (mapping) {\n  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n};\nTextBookmark.prototype.resolve = function resolve (doc) {\n  return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n};\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nvar NodeSelection = /*@__PURE__*/(function (Selection) {\n  function NodeSelection($pos) {\n    var node = $pos.nodeAfter;\n    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    Selection.call(this, $pos, $end);\n    // :: Node The selected node.\n    this.node = node;\n  }\n\n  if ( Selection ) NodeSelection.__proto__ = Selection;\n  NodeSelection.prototype = Object.create( Selection && Selection.prototype );\n  NodeSelection.prototype.constructor = NodeSelection;\n\n  NodeSelection.prototype.map = function map (doc, mapping) {\n    var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n    var $pos = doc.resolve(pos);\n    if (deleted) { return Selection.near($pos) }\n    return new NodeSelection($pos)\n  };\n\n  NodeSelection.prototype.content = function content () {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  };\n\n  NodeSelection.prototype.eq = function eq (other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  };\n\n  NodeSelection.prototype.toJSON = function toJSON () {\n    return {type: \"node\", anchor: this.anchor}\n  };\n\n  NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };\n\n  NodeSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\")\n      { throw new RangeError(\"Invalid input for NodeSelection.fromJSON\") }\n    return new NodeSelection(doc.resolve(json.anchor))\n  };\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  NodeSelection.create = function create (doc, from) {\n    return new this(doc.resolve(from))\n  };\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  NodeSelection.isSelectable = function isSelectable (node) {\n    return !node.isText && node.type.spec.selectable !== false\n  };\n\n  return NodeSelection;\n}(Selection));\n\nNodeSelection.prototype.visible = false;\n\nSelection.jsonID(\"node\", NodeSelection);\n\nvar NodeBookmark = function NodeBookmark(anchor) {\n  this.anchor = anchor;\n};\nNodeBookmark.prototype.map = function map (mapping) {\n  var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n};\nNodeBookmark.prototype.resolve = function resolve (doc) {\n  var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n  if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }\n  return Selection.near($pos)\n};\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nvar AllSelection = /*@__PURE__*/(function (Selection) {\n  function AllSelection(doc) {\n    Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));\n  }\n\n  if ( Selection ) AllSelection.__proto__ = Selection;\n  AllSelection.prototype = Object.create( Selection && Selection.prototype );\n  AllSelection.prototype.constructor = AllSelection;\n\n  AllSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size);\n      var sel = Selection.atStart(tr.doc);\n      if (!sel.eq(tr.selection)) { tr.setSelection(sel); }\n    } else {\n      Selection.prototype.replace.call(this, tr, content);\n    }\n  };\n\n  AllSelection.prototype.toJSON = function toJSON () { return {type: \"all\"} };\n\n  AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };\n\n  AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };\n\n  return AllSelection;\n}(Selection));\n\nSelection.jsonID(\"all\", AllSelection);\n\nvar AllBookmark = {\n  map: function map() { return this },\n  resolve: function resolve(doc) { return new AllSelection(doc) }\n};\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) { return TextSelection.create(doc, pos) }\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (!child.isAtom) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) { return inner }\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir;\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n  if (last < startLen) { return }\n  var step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) { return }\n  var map = tr.mapping.maps[last], end;\n  map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nvar UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nvar Transaction = /*@__PURE__*/(function (Transform) {\n  function Transaction(state) {\n    Transform.call(this, state.doc);\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now();\n    this.curSelection = state.selection;\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0;\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks;\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0;\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null);\n  }\n\n  if ( Transform ) Transaction.__proto__ = Transform;\n  Transaction.prototype = Object.create( Transform && Transform.prototype );\n  Transaction.prototype.constructor = Transaction;\n\n  var prototypeAccessors = { selection: { configurable: true },selectionSet: { configurable: true },storedMarksSet: { configurable: true },isGeneric: { configurable: true },scrolledIntoView: { configurable: true } };\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  prototypeAccessors.selection.get = function () {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n      this.curSelectionFor = this.steps.length;\n    }\n    return this.curSelection\n  };\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  Transaction.prototype.setSelection = function setSelection (selection) {\n    if (selection.$from.doc != this.doc)\n      { throw new RangeError(\"Selection passed to setSelection must point at the current document\") }\n    this.curSelection = selection;\n    this.curSelectionFor = this.steps.length;\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n    this.storedMarks = null;\n    return this\n  };\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  prototypeAccessors.selectionSet.get = function () {\n    return (this.updated & UPDATED_SEL) > 0\n  };\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {\n    this.storedMarks = marks;\n    this.updated |= UPDATED_MARKS;\n    return this\n  };\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  Transaction.prototype.ensureMarks = function ensureMarks (marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      { this.setStoredMarks(marks); }\n    return this\n  };\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  Transaction.prototype.addStoredMark = function addStoredMark (mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  prototypeAccessors.storedMarksSet.get = function () {\n    return (this.updated & UPDATED_MARKS) > 0\n  };\n\n  Transaction.prototype.addStep = function addStep (step, doc) {\n    Transform.prototype.addStep.call(this, step, doc);\n    this.updated = this.updated & ~UPDATED_MARKS;\n    this.storedMarks = null;\n  };\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  Transaction.prototype.setTime = function setTime (time) {\n    this.time = time;\n    return this\n  };\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  Transaction.prototype.replaceSelection = function replaceSelection (slice) {\n    this.selection.replace(this, slice);\n    return this\n  };\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {\n    var selection = this.selection;\n    if (inheritMarks !== false)\n      { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none))); }\n    selection.replaceWith(this, node);\n    return this\n  };\n\n  // :: () → Transaction\n  // Delete the selection.\n  Transaction.prototype.deleteSelection = function deleteSelection () {\n    this.selection.replace(this);\n    return this\n  };\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  Transaction.prototype.insertText = function insertText (text, from, to) {\n    if ( to === void 0 ) to = from;\n\n    var schema = this.doc.type.schema;\n    if (from == null) {\n      if (!text) { return this.deleteSelection() }\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) { return this.deleteRange(from, to) }\n      var marks = this.storedMarks;\n      if (!marks) {\n        var $from = this.doc.resolve(from);\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks));\n      if (!this.selection.empty) { this.setSelection(Selection.near(this.selection.$to)); }\n      return this\n    }\n  };\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  Transaction.prototype.setMeta = function setMeta (key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value;\n    return this\n  };\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  Transaction.prototype.getMeta = function getMeta (key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  };\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  prototypeAccessors.isGeneric.get = function () {\n    for (var _ in this.meta) { return false }\n    return true\n  };\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  Transaction.prototype.scrollIntoView = function scrollIntoView () {\n    this.updated |= UPDATED_SCROLL;\n    return this\n  };\n\n  prototypeAccessors.scrolledIntoView.get = function () {\n    return (this.updated & UPDATED_SCROLL) > 0\n  };\n\n  Object.defineProperties( Transaction.prototype, prototypeAccessors );\n\n  return Transaction;\n}(Transform));\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nvar FieldDesc = function FieldDesc(name, desc, self) {\n  this.name = name;\n  this.init = bind(desc.init, self);\n  this.apply = bind(desc.apply, self);\n};\n\nvar baseFields = [\n  new FieldDesc(\"doc\", {\n    init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply: function apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply: function apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init: function init(config) { return config.storedMarks || null },\n    apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init: function init() { return 0 },\n    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n];\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nvar Configuration = function Configuration(schema, plugins) {\n  var this$1 = this;\n\n  this.schema = schema;\n  this.fields = baseFields.concat();\n  this.plugins = [];\n  this.pluginsByKey = Object.create(null);\n  if (plugins) { plugins.forEach(function (plugin) {\n    if (this$1.pluginsByKey[plugin.key])\n      { throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\") }\n    this$1.plugins.push(plugin);\n    this$1.pluginsByKey[plugin.key] = plugin;\n    if (plugin.spec.state)\n      { this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }\n  }); }\n};\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nvar EditorState = function EditorState(config) {\n  this.config = config;\n};\n\nvar prototypeAccessors$1 = { schema: { configurable: true },plugins: { configurable: true },tr: { configurable: true } };\n\n// doc:: Node\n// The current document.\n\n// selection:: Selection\n// The selection.\n\n// storedMarks:: ?[Mark]\n// A set of marks to apply to the next input. Will be null when\n// no explicit marks have been set.\n\n// :: Schema\n// The schema of the state's document.\nprototypeAccessors$1.schema.get = function () {\n  return this.config.schema\n};\n\n// :: [Plugin]\n// The plugins that are active in this state.\nprototypeAccessors$1.plugins.get = function () {\n  return this.config.plugins\n};\n\n// :: (Transaction) → EditorState\n// Apply the given transaction to produce a new state.\nEditorState.prototype.apply = function apply (tr) {\n  return this.applyTransaction(tr).state\n};\n\n// : (Transaction) → bool\nEditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {\n    if ( ignore === void 0 ) ignore = -1;\n\n  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {\n    var plugin = this.config.plugins[i];\n    if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n      { return false }\n  } }\n  return true\n};\n\n// :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n// Verbose variant of [`apply`](#state.EditorState.apply) that\n// returns the precise transactions that were applied (which might\n// be influenced by the [transaction\n// hooks](#state.PluginSpec.filterTransaction) of\n// plugins) along with the new state.\nEditorState.prototype.applyTransaction = function applyTransaction (rootTr) {\n  if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }\n\n  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n  // This loop repeatedly gives plugins a chance to respond to\n  // transactions as new transactions are added, making sure to only\n  // pass the transactions the plugin did not see before.\n   for (;;) {\n    var haveNew = false;\n    for (var i = 0; i < this.config.plugins.length; i++) {\n      var plugin = this.config.plugins[i];\n      if (plugin.spec.appendTransaction) {\n        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n        var tr = n < trs.length &&\n            plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n        if (tr && newState.filterTransaction(tr, i)) {\n          tr.setMeta(\"appendedTransaction\", rootTr);\n          if (!seen) {\n            seen = [];\n            for (var j = 0; j < this.config.plugins.length; j++)\n              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0}); }\n          }\n          trs.push(tr);\n          newState = newState.applyInner(tr);\n          haveNew = true;\n        }\n        if (seen) { seen[i] = {state: newState, n: trs.length}; }\n      }\n    }\n    if (!haveNew) { return {state: newState, transactions: trs} }\n  }\n};\n\n// : (Transaction) → EditorState\nEditorState.prototype.applyInner = function applyInner (tr) {\n  if (!tr.before.eq(this.doc)) { throw new RangeError(\"Applying a mismatched transaction\") }\n  var newInstance = new EditorState(this.config), fields = this.config.fields;\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n  }\n  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this, tr, newInstance); }\n  return newInstance\n};\n\n// :: Transaction\n// Start a [transaction](#state.Transaction) from this state.\nprototypeAccessors$1.tr.get = function () { return new Transaction(this) };\n\n// :: (Object) → EditorState\n// Create a new state.\n//\n// config::- Configuration options. Must contain `schema` or `doc` (or both).\n//\n//    schema:: ?Schema\n//    The schema to use (only relevant if no `doc` is specified).\n//\n//    doc:: ?Node\n//    The starting document.\n//\n//    selection:: ?Selection\n//    A valid selection in the document.\n//\n//    storedMarks:: ?[Mark]\n//    The initial set of [stored marks](#state.EditorState.storedMarks).\n//\n//    plugins:: ?[Plugin]\n//    The plugins that should be active in this state.\nEditorState.create = function create (config) {\n  var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n  var instance = new EditorState($config);\n  for (var i = 0; i < $config.fields.length; i++)\n    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }\n  return instance\n};\n\n// :: (Object) → EditorState\n// Create a new state based on this one, but with an adjusted set of\n// active plugins. State fields that exist in both sets of plugins\n// are kept unchanged. Those that no longer exist are dropped, and\n// those that are new are initialized using their\n// [`init`](#state.StateField.init) method, passing in the new\n// configuration object..\n//\n// config::- configuration options\n//\n//   plugins:: [Plugin]\n//   New set of active plugins.\nEditorState.prototype.reconfigure = function reconfigure (config) {\n  var $config = new Configuration(this.schema, config.plugins);\n  var fields = $config.fields, instance = new EditorState($config);\n  for (var i = 0; i < fields.length; i++) {\n    var name = fields[i].name;\n    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n  }\n  return instance\n};\n\n// :: (?union<Object<Plugin>, string, number>) → Object\n// Serialize this state to JSON. If you want to serialize the state\n// of plugins, pass an object mapping property names to use in the\n// resulting JSON object to plugin objects. The argument may also be\n// a string or number, in which case it is ignored, to support the\n// way `JSON.stringify` calls `toString` methods.\nEditorState.prototype.toJSON = function toJSON (pluginFields) {\n  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};\n  if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }\n  if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {\n    if (prop == \"doc\" || prop == \"selection\")\n      { throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\") }\n    var plugin = pluginFields[prop], state = plugin.spec.state;\n    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this[plugin.key]); }\n  } }\n  return result\n};\n\n// :: (Object, Object, ?Object<Plugin>) → EditorState\n// Deserialize a JSON representation of a state. `config` should\n// have at least a `schema` field, and should contain array of\n// plugins to initialize the state with. `pluginFields` can be used\n// to deserialize the state of plugins, by associating plugin\n// instances with the property names they use in the JSON object.\n//\n// config::- configuration options\n//\n//   schema:: Schema\n//   The schema to use.\n//\n//   plugins:: ?[Plugin]\n//   The set of active plugins.\nEditorState.fromJSON = function fromJSON (config, json, pluginFields) {\n  if (!json) { throw new RangeError(\"Invalid input for EditorState.fromJSON\") }\n  if (!config.schema) { throw new RangeError(\"Required config field 'schema' missing\") }\n  var $config = new Configuration(config.schema, config.plugins);\n  var instance = new EditorState($config);\n  $config.fields.forEach(function (field) {\n    if (field.name == \"doc\") {\n      instance.doc = Node.fromJSON(config.schema, json.doc);\n    } else if (field.name == \"selection\") {\n      instance.selection = Selection.fromJSON(instance.doc, json.selection);\n    } else if (field.name == \"storedMarks\") {\n      if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }\n    } else {\n      if (pluginFields) { for (var prop in pluginFields) {\n        var plugin = pluginFields[prop], state = plugin.spec.state;\n        if (plugin.key == field.name && state && state.fromJSON &&\n            Object.prototype.hasOwnProperty.call(json, prop)) {\n          // This field belongs to a plugin mapped to a JSON field, read it from there.\n          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n          return\n        }\n      } }\n      instance[field.name] = field.init(config, instance);\n    }\n  });\n  return instance\n};\n\n// Kludge to allow the view to track mappings between different\n// instances of a state.\n//\n// FIXME this is no longer needed as of prosemirror-view 1.9.0,\n// though due to backwards-compat we should probably keep it around\n// for a while (if only as a no-op)\nEditorState.addApplyListener = function addApplyListener (f) {\n  applyListeners.push(f);\n};\nEditorState.removeApplyListener = function removeApplyListener (f) {\n  var found = applyListeners.indexOf(f);\n  if (found > -1) { applyListeners.splice(found, 1); }\n};\n\nObject.defineProperties( EditorState.prototype, prototypeAccessors$1 );\n\nvar applyListeners = [];\n\n// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (var prop in obj) {\n    var val = obj[prop];\n    if (val instanceof Function) { val = val.bind(self); }\n    else if (prop == \"handleDOMEvents\") { val = bindProps(val, self, {}); }\n    target[prop] = val;\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nvar Plugin = function Plugin(spec) {\n  // :: EditorProps\n  // The [props](#view.EditorProps) exported by this plugin.\n  this.props = {};\n  if (spec.props) { bindProps(spec.props, this, this.props); }\n  // :: Object\n  // The plugin's [spec object](#state.PluginSpec).\n  this.spec = spec;\n  this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n};\n\n// :: (EditorState) → any\n// Extract the plugin's state field from an editor state.\nPlugin.prototype.getState = function getState (state) { return state[this.key] };\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nvar keys = Object.create(null);\n\nfunction createKey(name) {\n  if (name in keys) { return name + \"$\" + ++keys[name] }\n  keys[name] = 0;\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nvar PluginKey = function PluginKey(name) {\nif ( name === void 0 ) name = \"key\";\n this.key = createKey(name); };\n\n// :: (EditorState) → ?Plugin\n// Get the active plugin with this key, if any, from an editor\n// state.\nPluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };\n\n// :: (EditorState) → ?any\n// Get the plugin's state from an editor state.\nPluginKey.prototype.getState = function getState (state) { return state[this.key] };\n\nexport { AllSelection, EditorState, NodeSelection, Plugin, PluginKey, Selection, SelectionRange, TextSelection, Transaction };\n//# sourceMappingURL=index.es.js.map\n","import { ReplaceError, Slice, Fragment, MarkType } from 'prosemirror-model';\n\n// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nvar MapResult = function MapResult(pos, deleted, recover) {\n  if ( deleted === void 0 ) deleted = false;\n  if ( recover === void 0 ) recover = null;\n\n  // :: number The mapped version of the position.\n  this.pos = pos;\n  // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n  this.deleted = deleted;\n  this.recover = recover;\n};\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nvar StepMap = function StepMap(ranges, inverted) {\n  if ( inverted === void 0 ) inverted = false;\n\n  this.ranges = ranges;\n  this.inverted = inverted;\n};\n\nStepMap.prototype.recover = function recover (value) {\n  var diff = 0, index = recoverIndex(value);\n  if (!this.inverted) { for (var i = 0; i < index; i++)\n    { diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; } }\n  return this.ranges[index * 3] + diff + recoverOffset(value)\n};\n\n// : (number, ?number) → MapResult\nStepMap.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\n// : (number, ?number) → number\nStepMap.prototype.map = function map (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, true) };\n\nStepMap.prototype._map = function _map (pos, assoc, simple) {\n  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n    if (pos <= end) {\n      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n      var result = start + diff + (side < 0 ? 0 : newSize);\n      if (simple) { return result }\n      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n    }\n    diff += newSize - oldSize;\n  }\n  return simple ? pos + diff : new MapResult(pos + diff)\n};\n\nStepMap.prototype.touches = function touches (pos, recover) {\n  var diff = 0, index = recoverIndex(recover);\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n    if (pos <= end && i == index * 3) { return true }\n    diff += this.ranges[i + newIndex] - oldSize;\n  }\n  return false\n};\n\n// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n// Calls the given function on each of the changed ranges included in\n// this map.\nStepMap.prototype.forEach = function forEach (f) {\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n    diff += newSize - oldSize;\n  }\n};\n\n// :: () → StepMap\n// Create an inverted version of this map. The result can be used to\n// map positions in the post-step document to the pre-step document.\nStepMap.prototype.invert = function invert () {\n  return new StepMap(this.ranges, !this.inverted)\n};\n\nStepMap.prototype.toString = function toString () {\n  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n};\n\n// :: (n: number) → StepMap\n// Create a map that moves all positions by offset `n` (which may be\n// negative). This can be useful when applying steps meant for a\n// sub-document to a larger document, or vice-versa.\nStepMap.offset = function offset (n) {\n  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n};\n\nStepMap.empty = new StepMap([]);\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nvar Mapping = function Mapping(maps, mirror, from, to) {\n  // :: [StepMap]\n  // The step maps in this mapping.\n  this.maps = maps || [];\n  // :: number\n  // The starting position in the `maps` array, used when `map` or\n  // `mapResult` is called.\n  this.from = from || 0;\n  // :: number\n  // The end position in the `maps` array.\n  this.to = to == null ? this.maps.length : to;\n  this.mirror = mirror;\n};\n\n// :: (?number, ?number) → Mapping\n// Create a mapping that maps only through a part of this one.\nMapping.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.maps.length;\n\n  return new Mapping(this.maps, this.mirror, from, to)\n};\n\nMapping.prototype.copy = function copy () {\n  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n};\n\n// :: (StepMap, ?number)\n// Add a step map to the end of this mapping. If `mirrors` is\n// given, it should be the index of the step map that is the mirror\n// image of this one.\nMapping.prototype.appendMap = function appendMap (map, mirrors) {\n  this.to = this.maps.push(map);\n  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }\n};\n\n// :: (Mapping)\n// Add all the step maps in a given mapping to this one (preserving\n// mirroring information).\nMapping.prototype.appendMapping = function appendMapping (mapping) {\n  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);\n  }\n};\n\n// :: (number) → ?number\n// Finds the offset of the step map that mirrors the map at the\n// given offset, in this mapping (as per the second argument to\n// `appendMap`).\nMapping.prototype.getMirror = function getMirror (n) {\n  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)\n    { if (this.mirror[i] == n) { return this.mirror[i + (i % 2 ? -1 : 1)] } } }\n};\n\nMapping.prototype.setMirror = function setMirror (n, m) {\n  if (!this.mirror) { this.mirror = []; }\n  this.mirror.push(n, m);\n};\n\n// :: (Mapping)\n// Append the inverse of the given mapping to this one.\nMapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {\n  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);\n  }\n};\n\n// :: () → Mapping\n// Create an inverted version of this mapping.\nMapping.prototype.invert = function invert () {\n  var inverse = new Mapping;\n  inverse.appendMappingInverted(this);\n  return inverse\n};\n\n// : (number, ?number) → number\n// Map a position through this mapping.\nMapping.prototype.map = function map (pos, assoc) {\n    if ( assoc === void 0 ) assoc = 1;\n\n  if (this.mirror) { return this._map(pos, assoc, true) }\n  for (var i = this.from; i < this.to; i++)\n    { pos = this.maps[i].map(pos, assoc); }\n  return pos\n};\n\n// : (number, ?number) → MapResult\n// Map a position through this mapping, returning a mapping\n// result.\nMapping.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\nMapping.prototype._map = function _map (pos, assoc, simple) {\n  var deleted = false;\n\n  for (var i = this.from; i < this.to; i++) {\n    var map = this.maps[i], result = map.mapResult(pos, assoc);\n    if (result.recover != null) {\n      var corr = this.getMirror(i);\n      if (corr != null && corr > i && corr < this.to) {\n        i = corr;\n        pos = this.maps[corr].recover(result.recover);\n        continue\n      }\n    }\n\n    if (result.deleted) { deleted = true; }\n    pos = result.pos;\n  }\n\n  return simple ? pos : new MapResult(pos, deleted)\n};\n\nfunction TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nvar Transform = function Transform(doc) {\n  // :: Node\n  // The current document (the result of applying the steps in the\n  // transform).\n  this.doc = doc;\n  // :: [Step]\n  // The steps in this transform.\n  this.steps = [];\n  // :: [Node]\n  // The documents before each of the steps.\n  this.docs = [];\n  // :: Mapping\n  // A mapping with the maps for each of the steps in this transform.\n  this.mapping = new Mapping;\n};\n\nvar prototypeAccessors = { before: { configurable: true },docChanged: { configurable: true } };\n\n// :: Node The starting document.\nprototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };\n\n// :: (step: Step) → this\n// Apply a new step in this transform, saving the result. Throws an\n// error when the step fails.\nTransform.prototype.step = function step (object) {\n  var result = this.maybeStep(object);\n  if (result.failed) { throw new TransformError(result.failed) }\n  return this\n};\n\n// :: (Step) → StepResult\n// Try to apply a step in this transformation, ignoring it if it\n// fails. Returns the step result.\nTransform.prototype.maybeStep = function maybeStep (step) {\n  var result = step.apply(this.doc);\n  if (!result.failed) { this.addStep(step, result.doc); }\n  return result\n};\n\n// :: bool\n// True when the document has been changed (when there are any\n// steps).\nprototypeAccessors.docChanged.get = function () {\n  return this.steps.length > 0\n};\n\nTransform.prototype.addStep = function addStep (step, doc) {\n  this.docs.push(this.doc);\n  this.steps.push(step);\n  this.mapping.appendMap(step.getMap());\n  this.doc = doc;\n};\n\nObject.defineProperties( Transform.prototype, prototypeAccessors );\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nvar stepsByID = Object.create(null);\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nvar Step = function Step () {};\n\nStep.prototype.apply = function apply (_doc) { return mustOverride() };\n\n// :: () → StepMap\n// Get the step map that represents the changes made by this step,\n// and which can be used to transform between positions in the old\n// and the new document.\nStep.prototype.getMap = function getMap () { return StepMap.empty };\n\n// :: (doc: Node) → Step\n// Create an inverted version of this step. Needs the document as it\n// was before the step as argument.\nStep.prototype.invert = function invert (_doc) { return mustOverride() };\n\n// :: (mapping: Mappable) → ?Step\n// Map this step through a mappable thing, returning either a\n// version of that step with its positions adjusted, or `null` if\n// the step was entirely deleted by the mapping.\nStep.prototype.map = function map (_mapping) { return mustOverride() };\n\n// :: (other: Step) → ?Step\n// Try to merge this step with another one, to be applied directly\n// after it. Returns the merged step when possible, null if the\n// steps can't be merged.\nStep.prototype.merge = function merge (_other) { return null };\n\n// :: () → Object\n// Create a JSON-serializeable representation of this step. When\n// defining this for a custom subclass, make sure the result object\n// includes the step type's [JSON id](#transform.Step^jsonID) under\n// the `stepType` property.\nStep.prototype.toJSON = function toJSON () { return mustOverride() };\n\n// :: (Schema, Object) → Step\n// Deserialize a step from its JSON representation. Will call\n// through to the step class' own implementation of this method.\nStep.fromJSON = function fromJSON (schema, json) {\n  if (!json || !json.stepType) { throw new RangeError(\"Invalid input for Step.fromJSON\") }\n  var type = stepsByID[json.stepType];\n  if (!type) { throw new RangeError((\"No step type \" + (json.stepType) + \" defined\")) }\n  return type.fromJSON(schema, json)\n};\n\n// :: (string, constructor<Step>)\n// To be able to serialize steps to JSON, each step needs a string\n// ID to attach to its JSON representation. Use this method to\n// register an ID for your step classes. Try to pick something\n// that's unlikely to clash with steps from other modules.\nStep.jsonID = function jsonID (id, stepClass) {\n  if (id in stepsByID) { throw new RangeError(\"Duplicate use of step JSON ID \" + id) }\n  stepsByID[id] = stepClass;\n  stepClass.prototype.jsonID = id;\n  return stepClass\n};\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nvar StepResult = function StepResult(doc, failed) {\n  // :: ?Node The transformed document.\n  this.doc = doc;\n  // :: ?string Text providing information about a failed step.\n  this.failed = failed;\n};\n\n// :: (Node) → StepResult\n// Create a successful step result.\nStepResult.ok = function ok (doc) { return new StepResult(doc, null) };\n\n// :: (string) → StepResult\n// Create a failed step result.\nStepResult.fail = function fail (message) { return new StepResult(null, message) };\n\n// :: (Node, number, number, Slice) → StepResult\n// Call [`Node.replace`](#model.Node.replace) with the given\n// arguments. Create a successful result if it succeeds, and a\n// failed one if it throws a `ReplaceError`.\nStepResult.fromReplace = function fromReplace (doc, from, to, slice) {\n  try {\n    return StepResult.ok(doc.replace(from, to, slice))\n  } catch (e) {\n    if (e instanceof ReplaceError) { return StepResult.fail(e.message) }\n    throw e\n  }\n};\n\n// ::- Replace a part of the document with a slice of new content.\nvar ReplaceStep = /*@__PURE__*/(function (Step) {\n  function ReplaceStep(from, to, slice, structure) {\n    Step.call(this);\n    // :: number\n    // The start position of the replaced range.\n    this.from = from;\n    // :: number\n    // The end position of the replaced range.\n    this.to = to;\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice;\n    this.structure = !!structure;\n  }\n\n  if ( Step ) ReplaceStep.__proto__ = Step;\n  ReplaceStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceStep.prototype.constructor = ReplaceStep;\n\n  ReplaceStep.prototype.apply = function apply (doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      { return StepResult.fail(\"Structure replace would overwrite content\") }\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  };\n\n  ReplaceStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  };\n\n  ReplaceStep.prototype.invert = function invert (doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  };\n\n  ReplaceStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted) { return null }\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  };\n\n  ReplaceStep.prototype.merge = function merge (other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) { return null }\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      var slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice$1, this.structure)\n    } else {\n      return null\n    }\n  };\n\n  ReplaceStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replace\", from: this.from, to: this.to};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\") }\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  };\n\n  return ReplaceStep;\n}(Step));\n\nStep.jsonID(\"replace\", ReplaceStep);\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nvar ReplaceAroundStep = /*@__PURE__*/(function (Step) {\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    Step.call(this);\n    // :: number\n    // The start position of the replaced range.\n    this.from = from;\n    // :: number\n    // The end position of the replaced range.\n    this.to = to;\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom;\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo;\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice;\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert;\n    this.structure = !!structure;\n  }\n\n  if ( Step ) ReplaceAroundStep.__proto__ = Step;\n  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\n  ReplaceAroundStep.prototype.apply = function apply (doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      { return StepResult.fail(\"Structure gap-replace would overwrite content\") }\n\n    var gap = doc.slice(this.gapFrom, this.gapTo);\n    if (gap.openStart || gap.openEnd)\n      { return StepResult.fail(\"Gap is not a flat range\") }\n    var inserted = this.slice.insertAt(this.insert, gap.content);\n    if (!inserted) { return StepResult.fail(\"Content does not fit in gap\") }\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  };\n\n  ReplaceAroundStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  };\n\n  ReplaceAroundStep.prototype.invert = function invert (doc) {\n    var gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\") }\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  };\n\n  return ReplaceAroundStep;\n}(Step));\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf) { return true }\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false\n}\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      { return depth }\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) { break }\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  var $from = range.$from;\n  var $to = range.$to;\n  var depth = range.depth;\n\n  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n  var start = gapStart, end = gapEnd;\n\n  var before = Fragment.empty, openStart = 0;\n  for (var d = depth, splitting = false; d > target; d--)\n    { if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    } }\n  var after = Fragment.empty, openEnd = 0;\n  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)\n    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n      splitting$1 = true;\n      after = Fragment.from($to.node(d$1).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    } }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n};\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nfunction findWrapping(range, nodeType, attrs, innerRange) {\n  if ( innerRange === void 0 ) innerRange = range;\n\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n  if (!inner) { return null }\n  return around.map(withAttrs).concat({type: nodeType, attrs: attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type: type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n  if (!around) { return null }\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n  if (!inside) { return null }\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n  for (var i = startIndex; innerMatch && i < endIndex; i++)\n    { innerMatch = innerMatch.matchType(parent.child(i).type); }\n  if (!innerMatch || !innerMatch.validEnd) { return null }\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  var content = Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--)\n    { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }\n\n  var start = range.start, end = range.end;\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n};\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to, type, attrs) {\n  var this$1 = this;\n  if ( to === void 0 ) to = from;\n\n  if (!type.isTextblock) { throw new RangeError(\"Type given to setBlockType should be a textblock\") }\n  var mapFrom = this.steps.length;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);\n      var mapping = this$1.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false\n    }\n  });\n  return this\n};\n\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  var node = this.doc.nodeAt(pos);\n  if (!node) { throw new RangeError(\"No node at given position\") }\n  if (!type) { type = node.type; }\n  var newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf)\n    { return this.replaceWith(pos, pos + node.nodeSize, newNode) }\n\n  if (!type.validContent(node.content))\n    { throw new RangeError(\"Invalid content for node type \" + type.name) }\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n};\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nfunction canSplit(doc, pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = doc.resolve(pos), base = $pos.depth - depth;\n  var innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    { return false }\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d), index$1 = $pos.index(d);\n    if (node.type.spec.isolating) { return false }\n    var rest = node.content.cutByIndex(index$1, node.childCount);\n    var after = (typesAfter && typesAfter[i]) || node;\n    if (after != node) { rest = rest.replaceChild(0, after.type.create(after.attrs)); }\n    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest))\n      { return false }\n  }\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n};\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nfunction joinPoint(doc, pos, dir) {\n  if ( dir === void 0 ) dir = -1;\n\n  var $pos = doc.resolve(pos);\n  for (var d = $pos.depth;; d--) {\n    var before = (void 0), after = (void 0), index = $pos.index(d);\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) { return pos }\n    if (d == 0) { break }\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth) {\n  if ( depth === void 0 ) depth = 1;\n\n  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);\n  return this.step(step)\n};\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }\n\n  if ($pos.parentOffset == 0)\n    { for (var d = $pos.depth - 1; d >= 0; d--) {\n      var index = $pos.index(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }\n      if (index > 0) { return null }\n    } }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n      var index$1 = $pos.indexAfter(d$1);\n      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }\n      if (index$1 < $pos.node(d$1).childCount) { return null }\n    } }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n  if (!slice.content.size) { return pos }\n  var content = slice.content;\n  for (var i = 0; i < slice.openStart; i++) { content = content.firstChild.content; }\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      var parent = $pos.node(d), fits = false;\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n      if (fits)\n        { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }\n    }\n  }\n  return null\n}\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }\n    if (child.isInline) { child = f(child, parent, i); }\n    mapped.push(child);\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nvar AddMarkStep = /*@__PURE__*/(function (Step) {\n  function AddMarkStep(from, to, mark) {\n    Step.call(this);\n    // :: number\n    // The start of the marked range.\n    this.from = from;\n    // :: number\n    // The end of the marked range.\n    this.to = to;\n    // :: Mark\n    // The mark to add.\n    this.mark = mark;\n  }\n\n  if ( Step ) AddMarkStep.__proto__ = Step;\n  AddMarkStep.prototype = Object.create( Step && Step.prototype );\n  AddMarkStep.prototype.constructor = AddMarkStep;\n\n  AddMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n    var parent = $from.node($from.sharedDepth(this.to));\n    var slice = new Slice(mapFragment(oldSlice.content, function (node, parent) {\n      if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) { return node }\n      return node.mark(this$1.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  AddMarkStep.prototype.invert = function invert () {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  };\n\n  AddMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  AddMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark) }\n  };\n\n  AddMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  AddMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\") }\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return AddMarkStep;\n}(Step));\n\nStep.jsonID(\"addMark\", AddMarkStep);\n\n// ::- Remove a mark from all inline content between two positions.\nvar RemoveMarkStep = /*@__PURE__*/(function (Step) {\n  function RemoveMarkStep(from, to, mark) {\n    Step.call(this);\n    // :: number\n    // The start of the unmarked range.\n    this.from = from;\n    // :: number\n    // The end of the unmarked range.\n    this.to = to;\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark;\n  }\n\n  if ( Step ) RemoveMarkStep.__proto__ = Step;\n  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );\n  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\n  RemoveMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to);\n    var slice = new Slice(mapFragment(oldSlice.content, function (node) {\n      return node.mark(this$1.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  RemoveMarkStep.prototype.invert = function invert () {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  };\n\n  RemoveMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  RemoveMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark) }\n  };\n\n  RemoveMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\") }\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return RemoveMarkStep;\n}(Step));\n\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  var this$1 = this;\n\n  var removed = [], added = [], removing = null, adding = null;\n  this.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) { return }\n    var marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            { removing.to = end; }\n          else\n            { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }\n        }\n      }\n\n      if (adding && adding.to == start)\n        { adding.to = end; }\n      else\n        { added.push(adding = new AddMarkStep(start, end, mark)); }\n    }\n  });\n\n  removed.forEach(function (s) { return this$1.step(s); });\n  added.forEach(function (s) { return this$1.step(s); });\n  return this\n};\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark) {\n  var this$1 = this;\n  if ( mark === void 0 ) mark = null;\n\n  var matched = [], step = 0;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) { return }\n    step++;\n    var toRemove = null;\n    if (mark instanceof MarkType) {\n      var set = node.marks, found;\n      while (found = mark.isInSet(set)) {\n(toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) { toRemove = [mark]; }\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i], found$1 = (void 0);\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }\n        }\n        if (found$1) {\n          found$1.to = end;\n          found$1.step = step;\n        } else {\n          matched.push({style: style, from: Math.max(pos, from), to: end, step: step});\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });\n  return this\n};\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match) {\n  if ( match === void 0 ) match = parentType.contentMatch;\n\n  var node = this.doc.nodeAt(pos);\n  var delSteps = [], cur = pos + 1;\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i), end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type, child.attrs);\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty));\n    } else {\n      match = allowed;\n      for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))\n        { this.step(new RemoveMarkStep(cur, end, child.marks[j])); } }\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    var fill = match.fillBefore(Fragment.empty, true);\n    this.replace(cur, cur, new Slice(fill, 0, 0));\n  }\n  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this.step(delSteps[i$1]); }\n  return this\n};\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nfunction replaceStep(doc, from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  if (from == to && !slice.size) { return null }\n\n  var $from = doc.resolve(from), $to = doc.resolve(to);\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  var step = replaceStep(this.doc, from, to, slice);\n  if (step) { this.step(step); }\n  return this\n};\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n};\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n};\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nvar Fitter = function Fitter($from, $to, slice) {\n  this.$to = $to;\n  this.$from = $from;\n  this.unplaced = slice;\n\n  this.frontier = [];\n  for (var i = 0; i <= $from.depth; i++) {\n    var node = $from.node(i);\n    this.frontier.push({\n      type: node.type,\n      match: node.contentMatchAt($from.indexAfter(i))\n    });\n  }\n\n  this.placed = Fragment.empty;\n  for (var i$1 = $from.depth; i$1 > 0; i$1--)\n    { this.placed = Fragment.from($from.node(i$1).copy(this.placed)); }\n};\n\nvar prototypeAccessors$1 = { depth: { configurable: true } };\n\nprototypeAccessors$1.depth.get = function () { return this.frontier.length - 1 };\n\nFitter.prototype.fit = function fit () {\n  // As long as there's unplaced content, try to place some of it.\n  // If that fails, either increase the open score of the unplaced\n  // slice, or drop nodes from it, and then try again.\n  while (this.unplaced.size) {\n    var fit = this.findFittable();\n    if (fit) { this.placeNodes(fit); }\n    else { this.openMore() || this.dropNode(); }\n  }\n  // When there's inline content directly after the frontier _and_\n  // directly after `this.$to`, we must generate a `ReplaceAround`\n  // step that pulls that content into the node after the frontier.\n  // That means the fitting must be done to the end of the textblock\n  // node after `this.$to`, not `this.$to` itself.\n  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n  if (!$to) { return null }\n\n  // If closing to `$to` succeeded, create a step\n  var content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n  while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n    content = content.firstChild.content;\n    openStart--; openEnd--;\n  }\n  var slice = new Slice(content, openStart, openEnd);\n  if (moveInline > -1)\n    { return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize) }\n  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n    { return new ReplaceStep($from.pos, $to.pos, slice) }\n};\n\n// Find a position on the start spine of `this.unplaced` that has\n// content that can be moved somewhere on the frontier. Returns two\n// depths, one for the slice and one for the frontier.\nFitter.prototype.findFittable = function findFittable () {\n  // Only try wrapping nodes (pass 2) after finding a place without\n  // wrapping failed.\n  for (var pass = 1; pass <= 2; pass++) {\n    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n      var fragment = (void 0), parent = (void 0);\n      if (sliceDepth) {\n        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n        fragment = parent.content;\n      } else {\n        fragment = this.unplaced.content;\n      }\n      var first = fragment.firstChild;\n      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n        var ref = this.frontier[frontierDepth];\n          var type = ref.type;\n          var match = ref.match;\n          var wrap = (void 0), inject = (void 0);\n        // In pass 1, if the next node matches, or there is no next\n        // node but the parents look compatible, we've found a\n        // place.\n        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                          : type.compatibleContent(parent.type)))\n          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, inject: inject} }\n        // In pass 2, look for a set of wrapping nodes that make\n        // `first` fit here.\n        else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, wrap: wrap} }\n        // Don't continue looking further up if the parent node\n        // would fit here.\n        if (parent && match.matchType(parent.type)) { break }\n      }\n    }\n  }\n};\n\nFitter.prototype.openMore = function openMore () {\n  var ref = this.unplaced;\n    var content = ref.content;\n    var openStart = ref.openStart;\n    var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n  if (!inner.childCount || inner.firstChild.isLeaf) { return false }\n  this.unplaced = new Slice(content, openStart + 1,\n                            Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n  return true\n};\n\nFitter.prototype.dropNode = function dropNode () {\n  var ref = this.unplaced;\n    var content = ref.content;\n    var openStart = ref.openStart;\n    var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n  if (inner.childCount <= 1 && openStart > 0) {\n    var openAtEnd = content.size - openStart <= openStart + inner.size;\n    this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                              openAtEnd ? openStart - 1 : openEnd);\n  } else {\n    this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n  }\n};\n\n// : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n// Move content from the unplaced slice at `sliceDepth` to the\n// frontier node at `frontierDepth`. Close that frontier node when\n// applicable.\nFitter.prototype.placeNodes = function placeNodes (ref) {\n    var sliceDepth = ref.sliceDepth;\n    var frontierDepth = ref.frontierDepth;\n    var parent = ref.parent;\n    var inject = ref.inject;\n    var wrap = ref.wrap;\n\n  while (this.depth > frontierDepth) { this.closeFrontierNode(); }\n  if (wrap) { for (var i = 0; i < wrap.length; i++) { this.openFrontierNode(wrap[i]); } }\n\n  var slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n  var openStart = slice.openStart - sliceDepth;\n  var taken = 0, add = [];\n  var ref$1 = this.frontier[frontierDepth];\n    var match = ref$1.match;\n    var type = ref$1.type;\n  if (inject) {\n    for (var i$1 = 0; i$1 < inject.childCount; i$1++) { add.push(inject.child(i$1)); }\n    match = match.matchFragment(inject);\n  }\n  // Computes the amount of (end) open nodes at the end of the\n  // fragment. When 0, the parent is open, but no more. When\n  // negative, nothing is open.\n  var openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n  // Scan over the fragment, fitting as many child nodes as\n  // possible.\n  while (taken < fragment.childCount) {\n    var next = fragment.child(taken), matches = match.matchType(next.type);\n    if (!matches) { break }\n    taken++;\n    if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n      match = matches;\n      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                              taken == fragment.childCount ? openEndCount : -1));\n    }\n  }\n  var toEnd = taken == fragment.childCount;\n  if (!toEnd) { openEndCount = -1; }\n\n  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n  this.frontier[frontierDepth].match = match;\n\n  // If the parent types match, and the entire node was moved, and\n  // it's not open, close this frontier node right away.\n  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n    { this.closeFrontierNode(); }\n\n  // Add new frontier nodes for any open nodes at the end.\n  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {\n    var node = cur.lastChild;\n    this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)});\n    cur = node.content;\n  }\n\n  // Update `this.unplaced`. Drop the entire node from which we\n  // placed it we got to its end, otherwise just drop the placed\n  // nodes.\n  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n    : sliceDepth == 0 ? Slice.empty\n    : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n};\n\nFitter.prototype.mustMoveInline = function mustMoveInline () {\n  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) { return -1 }\n  var top = this.frontier[this.depth], level;\n  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n      (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) { return -1 }\n\n  var ref = this.$to;\n    var depth = ref.depth;\n    var after = this.$to.after(depth);\n  while (depth > 1 && after == this.$to.end(--depth)) { ++after; }\n  return after\n};\n\nFitter.prototype.findCloseLevel = function findCloseLevel ($to) {\n  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n    var ref = this.frontier[i];\n      var match = ref.match;\n      var type = ref.type;\n    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n    var fit = contentAfterFits($to, i, type, match, dropInner);\n    if (!fit) { continue }\n    for (var d = i - 1; d >= 0; d--) {\n      var ref$1 = this.frontier[d];\n        var match$1 = ref$1.match;\n        var type$1 = ref$1.type;\n      var matches = contentAfterFits($to, d, type$1, match$1, true);\n      if (!matches || matches.childCount) { continue scan }\n    }\n    return {depth: i, fit: fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n  }\n};\n\nFitter.prototype.close = function close ($to) {\n  var close = this.findCloseLevel($to);\n  if (!close) { return null }\n\n  while (this.depth > close.depth) { this.closeFrontierNode(); }\n  if (close.fit.childCount) { this.placed = addToFragment(this.placed, close.depth, close.fit); }\n  $to = close.move;\n  for (var d = close.depth + 1; d <= $to.depth; d++) {\n    var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n    this.openFrontierNode(node.type, node.attrs, add);\n  }\n  return $to\n};\n\nFitter.prototype.openFrontierNode = function openFrontierNode (type, attrs, content) {\n  var top = this.frontier[this.depth];\n  top.match = top.match.matchType(type);\n  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n  this.frontier.push({type: type, match: type.contentMatch});\n};\n\nFitter.prototype.closeFrontierNode = function closeFrontierNode () {\n  var open = this.frontier.pop();\n  var add = open.match.fillBefore(Fragment.empty, true);\n  if (add.childCount) { this.placed = addToFragment(this.placed, this.frontier.length, add); }\n};\n\nObject.defineProperties( Fitter.prototype, prototypeAccessors$1 );\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) { return fragment.cutByIndex(count) }\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) { return fragment.append(content) }\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) { fragment = fragment.firstChild.content; }\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) { return node }\n  var frag = node.content;\n  if (openStart > 1)\n    { frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0)); }\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0) { frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true)); }\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type)) { return null }\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++)\n    { if (!type.allowsMarks(fragment.child(i).marks)) { return true } }\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) { return this.deleteRange(from, to) }\n\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    { return this.step(new ReplaceStep(from, to, slice)) }\n\n  var targetDepths = coveredDepths($from, this.doc.resolve(to));\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n    if (spec.defining || spec.isolating) { break }\n    if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }\n    else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n\n  var leftNodes = [], preferredDepth = slice.openStart;\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart) { break }\n    content = node.content;\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    { preferredDepth -= 1; }\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    { preferredDepth -= 2; }\n\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n    if (!insert) { continue }\n    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }\n      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        { return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd)) }\n    }\n  }\n\n  var startSteps = this.steps.length;\n  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {\n    this.replace(from, to, slice);\n    if (this.steps.length > startSteps) { break }\n    var depth = targetDepths[i$2];\n    if (depth < 0) { continue }\n    from = $from.before(depth); to = $to.after(depth);\n  }\n  return this\n};\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(this.doc, from, node.type);\n    if (point != null) { from = to = point; }\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i], last = i == covered.length - 1;\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      { return this.delete($from.start(depth), $to.end(depth)) }\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      { return this.delete($from.before(depth), $to.after(depth)) }\n  }\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      { return this.delete($from.before(d), to) }\n  }\n  return this.delete(from, to)\n};\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  var result = [], minDepth = Math.min($from.depth, $to.depth);\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) { break }\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      { result.push(d); }\n  }\n  return result\n}\n\nexport { AddMarkStep, MapResult, Mapping, RemoveMarkStep, ReplaceAroundStep, ReplaceStep, Step, StepMap, StepResult, Transform, TransformError, canJoin, canSplit, dropPoint, findWrapping, insertPoint, joinPoint, liftTarget, replaceStep };\n//# sourceMappingURL=index.es.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const NODE_NAME = 'pm-data-grid';\n\nfunction defineElement() {\n  if (!customElements.get(NODE_NAME)) {\n    customElements.define(NODE_NAME, ProseMirrorDataGridElement);\n  }\n}\n\nfunction createElement(doc: Document): ProseMirrorDataGridElement {\n  defineElement();\n  return doc.createElement(NODE_NAME);\n}\n\nexport default class ProseMirrorDataGridElement extends HTMLElement {\n  static NODE_NAME = NODE_NAME;\n  static defineElement = defineElement;\n  static createElement = createElement;\n\n  constructor() {\n    super();\n  }\n}\n","import type { Node as ProsemirrorNode, DOMOutputSpec } from 'prosemirror-model';\nimport ProseMirrorDataGridElement from './ProseMirrorDataGridElement';\n\nexport const NODE_NAME = 'datagrid';\n\ntype DataGridNodeAttrs = {\n  entries: {\n    [key: string]: string;\n  };\n};\n\nfunction parseDOMAttributes(obj: string | Node): DataGridNodeAttrs {\n  if (!(obj instanceof HTMLElement)) {\n    throw new Error('Expect DOM Element');\n  }\n  const el: HTMLElement = obj;\n  return {\n    entries: {},\n  };\n}\n\nfunction toDOMAttributes(node: ProsemirrorNode): {\n  [name: string]: string;\n} {\n  return {};\n}\n\nconst DataGridNodeSpec = {\n  attrs: {\n    entries: { default: {} },\n  },\n  atom: true,\n  defining: true,\n  draggable: false,\n  group: 'block',\n  isolating: true,\n  selectable: true,\n  parseDOM: [\n    {\n      tag: ProseMirrorDataGridElement.NODE_NAME,\n      getAttrs: parseDOMAttributes,\n    },\n  ],\n  toDOM(node: ProsemirrorNode): DOMOutputSpec {\n    const domAttrs = toDOMAttributes(node);\n    const text = '[Data Grid]';\n    return [ProseMirrorDataGridElement.NODE_NAME, domAttrs, text];\n  },\n};\n\nexport default DataGridNodeSpec;\n","import { Transaction } from 'prosemirror-state';\nimport { Fragment, Schema } from 'prosemirror-model';\nimport { NODE_NAME } from './DataGridNodeSpec';\nimport { TextSelection } from 'prosemirror-state';\n\nexport default function insertDataGrid(\n  schema: Schema,\n  tr: Transaction,\n): Transaction {\n  const nodeType = schema.nodes[NODE_NAME];\n  if (!nodeType) {\n    return tr;\n  }\n\n  const { selection } = tr;\n  if (!(selection instanceof TextSelection)) {\n    return tr;\n  }\n\n  const attrs = {};\n  const node = nodeType.create(attrs);\n  const frag = Fragment.from(node);\n  const { to } = tr.selection;\n  tr = tr.insert(to, frag);\n  tr = tr.setSelection(TextSelection.create(tr.doc, to + 2));\n  return tr;\n}\n","import OrderedMap from 'orderedmap';\nimport DataGridNodeSpec, { NODE_NAME } from './DataGridNodeSpec';\nimport type { NodeSpec } from 'prosemirror-model';\n\nexport type createNodeSpecMapType = () => OrderedMap<NodeSpec>;\n\n// See https://prosemirror.net/docs/ref/#model.NodeSpec.\nexport default function createNodeSpecMap(): OrderedMap<NodeSpec> {\n  return OrderedMap.from({\n    [NODE_NAME]: DataGridNodeSpec,\n  });\n}\n","export default class Vector {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  equals(val: Vector): boolean {\n    return val.x === this.x && val.y === this.y;\n  }\n\n  getAngleFrom(point: Vector): number {\n    const dx = this.x - point.x;\n    const dy = this.y - point.y;\n    const val = (Math.atan2(dy, dx) * 180) / Math.PI;\n    let deg;\n    if (val >= -90 && val < 180) {\n      deg = val + 90;\n    } else {\n      deg = 360 + +90 + val;\n    }\n    // 270 ~ 360 |  0 ~  90\n    // ----------x----------\n    // 180 ~ 280 | 90 ~ 180\n    return Math.round(deg);\n  }\n\n  toString() {\n    return `Vector(${this.x}, ${this.y})`;\n  }\n}\n","import Vector from './Vector';\n\nexport default class Box {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n\n  constructor(x: number, y: number, w: number, h: number) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n  }\n\n  clone(): Box {\n    return new Box(this.x, this.y, this.w, this.h);\n  }\n\n  equals(box: Box): boolean {\n    return (\n      box === this ||\n      (this.x === box.x &&\n        this.y === box.y &&\n        this.w === box.w &&\n        this.h === box.h)\n    );\n  }\n\n  intersects(box: Box): boolean {\n    return !(\n      this.x > box.x + box.w ||\n      this.x + this.w < box.x ||\n      this.y + this.h < box.y ||\n      this.y > box.y + box.h\n    );\n  }\n\n  contains(box: Box): boolean {\n    return (\n      this.x <= box.x &&\n      this.x + this.w >= box.x &&\n      this.y <= box.y &&\n      this.y + this.h >= box.y &&\n      this.w >= box.w &&\n      this.h >= box.h\n    );\n  }\n\n  isCorssBoundaryOf(box: Box): boolean {\n    return box.intersects(this) && !box.contains(this);\n  }\n\n  isInsideAtBoundaryOf(box: Box): boolean {\n    return (\n      (this.x === box.x ||\n        this.y === box.y ||\n        this.x + this.w === box.x + box.w ||\n        this.y + this.h === box.y + box.h) &&\n      box.contains(this)\n    );\n  }\n\n  isInsideOf(box: Box): boolean {\n    return box.contains(this);\n  }\n\n  isOutsideOf(box: Box): boolean {\n    return !box.contains(this);\n  }\n\n  getCenter(): Vector {\n    return new Vector(this.x + this.w / 2, this.y + this.h / 2);\n  }\n\n  moveBy(x: number, y: number): Box {\n    if (x === 0 && y === 0) {\n      return this;\n    }\n    return new Box(this.x + x, this.y + y, this.w, this.h);\n  }\n\n  resizeBy(w: number, h: number): Box {\n    if (w === 0 && h === 0) {\n      return this;\n    }\n    return new Box(this.x, this.y, this.w + w, this.h + h);\n  }\n\n  toString() {\n    return `Box(x:${this.x}, y:${this.y}, w:${this.w}, h:${this.h})`;\n  }\n}\n","type WheeListener = (e: WheelEvent) => void;\ntype MouseListener = (e: MouseEvent) => void;\ntype KeyboardListener = (e: KeyboardEvent) => void;\n\ntype EventRegistry = {\n  dom: any;\n  type: string;\n  listener: WheeListener | MouseListener | KeyboardListener;\n  capture: boolean;\n};\n\nexport default class DOMEventsHandler {\n  _entries: EventRegistry[];\n\n  constructor() {\n    this._entries = [];\n  }\n\n  destroy() {\n    this._entries.forEach((entry) => {\n      const { dom, type, capture, listener } = entry;\n      dom.removeEventListener(type, listener, capture);\n    });\n  }\n\n  onClick(dom: HTMLElement, listener: MouseListener, capture?: boolean | null) {\n    this._onMouseEvent('click', dom, listener, capture);\n  }\n\n  onMouseDown(\n    dom: HTMLElement,\n    listener: MouseListener,\n    capture?: boolean | null,\n  ) {\n    this._onMouseEvent('mousedown', dom, listener, capture);\n  }\n\n  onFocusIn(\n    dom: HTMLElement,\n    listener: EventListener,\n    capture?: boolean | null,\n  ) {\n    this._onEvent('focusin', dom, listener, capture);\n  }\n\n  onFocusOut(\n    dom: HTMLElement,\n    listener: EventListener,\n    capture?: boolean | null,\n  ) {\n    this._onEvent('focusout', dom, listener, capture);\n  }\n\n  onBlur(dom: HTMLElement, listener: EventListener, capture?: boolean | null) {\n    this._onEvent('focusout', dom, listener, capture);\n  }\n\n  onKeyDown(\n    dom: HTMLElement,\n    listener: KeyboardListener,\n    capture?: boolean | null,\n  ) {\n    this._onKeyboardEvent('keydown', dom, listener, capture);\n  }\n\n  onWheel(dom: HTMLElement, listener: WheeListener, capture?: boolean | null) {\n    const type = 'wheel';\n    const entry = { dom, type, listener, capture: !!capture };\n    this._entries.push(entry);\n    dom.addEventListener(type, listener, !!capture);\n  }\n\n  _onEvent(\n    type: string,\n    dom: HTMLElement,\n    listener: EventListener,\n    capture?: boolean | null,\n  ) {\n    const entry = { dom, type, listener, capture: !!capture };\n    this._entries.push(entry);\n    dom.addEventListener(type, listener, !!capture);\n  }\n\n  _onMouseEvent(\n    type: 'click' | 'mousedown',\n    dom: HTMLElement,\n    listener: MouseListener,\n    capture?: boolean | null,\n  ) {\n    const entry = { dom, type, listener, capture: !!capture };\n    this._entries.push(entry);\n    dom.addEventListener(type, listener, !!capture);\n  }\n\n  _onKeyboardEvent(\n    type: 'keydown',\n    dom: HTMLElement,\n    listener: KeyboardListener,\n    capture?: boolean | null,\n  ) {\n    const entry = { dom, type, listener, capture: !!capture };\n    this._entries.push(entry);\n    dom.addEventListener(type, listener, !!capture);\n  }\n}\n","export default function clamp(val: number, min: number, max: number) {\n  if (val < min) {\n    return min;\n  }\n  if (val > max) {\n    return max;\n  }\n  return val;\n}\n","import CanvasDataGridConfig from './CanvasDataGridConfig';\nimport nullthrows from 'nullthrows';\nimport Box from './Box';\n\n// \"12px Arial\"\nconst RE_FONT_VALUE = /^(\\d+)px\\s([A-ZA-z\\s]+)$/;\n\nexport default class DeviceRenderingContext {\n  ctx: CanvasRenderingContext2D;\n  dpi: number;\n\n  constructor(ctx: CanvasRenderingContext2D, config: CanvasDataGridConfig) {\n    const dpi = window.devicePixelRatio;\n    this.ctx = ctx;\n    this.dpi = dpi;\n  }\n\n  set font(val: string) {\n    const matches = val.match(RE_FONT_VALUE);\n    if (!matches) {\n      throw new Error(`unsupport font. expect \"12px Arial\"`);\n    }\n    const { dpi } = this;\n    const fontSize = parseInt(matches[1], 10);\n    const fontType = matches[2];\n    const font = `${fontSize * dpi}px ${fontType}`;\n    this.ctx.font = font;\n  }\n\n  set strokeStyle(val: string) {\n    this.ctx.strokeStyle = val;\n  }\n\n  // Lines can be drawn with the stroke(), strokeRect(), and strokeText()\n  // methods.\n  set lineWidth(val: number) {\n    this.ctx.lineWidth = val * this.dpi;\n  }\n\n  set fillStyle(val: string) {\n    this.ctx.fillStyle = val;\n  }\n\n  set shadowBlur(val: number) {\n    this.ctx.shadowBlur = val * this.dpi;\n  }\n\n  set shadowColor(val: string) {\n    this.ctx.shadowColor = val;\n  }\n\n  fillText(text: string, x: number, y: number, maxWidth?: number) {\n    const { ctx, dpi } = this;\n    if (typeof maxWidth === 'number') {\n      ctx.fillText(text, x * dpi, y * dpi, maxWidth * dpi);\n    } else {\n      ctx.fillText(text, x * dpi, y * dpi);\n    }\n  }\n\n  clearRect(x: number, y: number, w: number, h: number) {\n    const { ctx, dpi } = this;\n    ctx.clearRect(x * dpi, y * dpi, w * dpi, h * dpi);\n  }\n\n  strokeRect(x: number, y: number, w: number, h: number) {\n    const { ctx, dpi } = this;\n    ctx.strokeRect(x * dpi, y * dpi, w * dpi, h * dpi);\n  }\n\n  fillRect(x: number, y: number, w: number, h: number) {\n    const { ctx, dpi } = this;\n    ctx.fillRect(x * dpi, y * dpi, w * dpi, h * dpi);\n  }\n\n  moveTo(x: number, y: number) {\n    const { ctx, dpi } = this;\n    ctx.moveTo(x * dpi, y * dpi);\n  }\n\n  lineTo(x: number, y: number) {\n    const { ctx, dpi } = this;\n    ctx.lineTo(x * dpi, y * dpi);\n  }\n\n  stroke() {\n    this.ctx.stroke();\n  }\n\n  beginPath() {\n    this.ctx.beginPath();\n  }\n\n  closePath() {\n    this.ctx.closePath();\n  }\n}\n","export default function getCellEntryKey(\n  colIndex: number,\n  rowIndex: number,\n): string {\n  return `c_${colIndex}_${rowIndex}`;\n}\n","const cachedResult = new Map();\n\nfunction numToAZ(num: number): string {\n  return num <= 26\n    ? String.fromCharCode(num + 64)\n    : numToAZ(~~((num - 1) / 26)) + numToAZ(num % 26 || 26);\n}\n\nexport default function getIndexRowCellText(colIndex: number): string {\n  if (cachedResult.has(colIndex)) {\n    return cachedResult.get(colIndex);\n  }\n  const result = numToAZ(colIndex);\n  cachedResult.set(colIndex, result);\n  return result;\n}\n","import type { CanvasDataGridState } from './canvasDataGridState';\nimport getCellEntryKey from './getCellEntryKey';\nimport getIndexRowCellText from './getIndexRowCellText';\n\nexport default function getCellEntryContent(\n  state: CanvasDataGridState,\n  colIndex: number,\n  rowIndex: number,\n): string {\n  const key = getCellEntryKey(colIndex, rowIndex);\n  const content = state.proseMirror.node.attrs.entries[key];\n  if (colIndex === 0) {\n    return rowIndex === 0 ? '' : String(rowIndex);\n  }\n  if (rowIndex === 0) {\n    return colIndex === 0 ? '' : getIndexRowCellText(colIndex);\n  }\n  return content === undefined ? `${colIndex}, ${rowIndex}` : content;\n}\n","import CanvasDataGridRenderingContext from './CanvasDataGridRenderingContext';\nimport Box from './Box';\nimport nullthrows from 'nullthrows';\nimport CanvasDataGridConfig from './CanvasDataGridConfig';\nimport type { CanvasDataGridState } from './canvasDataGridState';\nimport getCellEntryContent from './getCellEntryContent';\n\ntype CellStyle = {\n  bgColor?: string | null;\n  borderColor?: string | null;\n};\n\nfunction setCanvasSize(\n  canvas: HTMLCanvasElement,\n  canvasBox: Box,\n  ctx: CanvasDataGridRenderingContext,\n) {\n  const { dpi } = ctx;\n  canvas.width = canvasBox.w * dpi;\n  canvas.height = canvasBox.h * dpi;\n  canvas.style.width = canvasBox.w + 'px';\n  canvas.style.height = canvasBox.h + 'px';\n}\n\nfunction renderCell(\n  ctx: CanvasDataGridRenderingContext,\n  config: CanvasDataGridConfig,\n  cellBox: Box,\n  text: string,\n  style?: CellStyle,\n) {\n  const {\n    cellPadding,\n    textSize,\n    textColor,\n    fontType,\n    cellBGColor,\n    cellBorderColor,\n  } = config;\n\n  const bgColor = style?.bgColor || cellBGColor;\n  const borderColor = style?.borderColor || cellBorderColor;\n\n  const { x, y, w, h } = cellBox;\n  // background.\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(x, y, w, h);\n\n  // border.\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = borderColor;\n  ctx.strokeRect(x, y, w, h);\n\n  if (text) {\n    ctx.fillStyle = textColor;\n    ctx.font = `${textSize}px ${fontType}`;\n    ctx.fillText(text, x + cellPadding, y + cellPadding + textSize);\n  }\n}\n\nfunction renderFixedShadow(\n  ctx: CanvasDataGridRenderingContext,\n  config: CanvasDataGridConfig,\n  shadowBox: Box,\n) {\n  const { shadowBlur, shadowColor, cellBGColor } = config;\n  const { x, y, w, h } = shadowBox;\n  ctx.clearRect(x, y, w, h);\n  ctx.shadowBlur = shadowBlur;\n  ctx.shadowColor = shadowColor;\n  ctx.fillStyle = cellBGColor;\n  ctx.fillRect(x, y, w, h);\n  ctx.shadowBlur = 0;\n}\n\nexport default function renderCanvasDataGrid(state: CanvasDataGridState) {\n  const { canvas, canvasBox, config, selection, rows, cols, fps } = state;\n  const {\n    cellBorderColor,\n    fixedColBGColor,\n    fixedColsCount,\n    fixedRowBGColor,\n    fixedRowsCount,\n    selectionBGColor,\n    selectionBorderColor,\n    shadowBlur,\n    shadowColor,\n    textColor,\n  } = config;\n\n  const anchorCol = selection.pos.x;\n  const anchorRow = selection.pos.y;\n  let anchorBox: Box | null = null;\n\n  const ctx = new CanvasDataGridRenderingContext(\n    nullthrows(nullthrows(canvas.getContext('2d'))),\n    config,\n  );\n\n  setCanvasSize(canvas, canvasBox, ctx);\n\n  ctx.clearRect(0, 0, canvasBox.w, canvasBox.h);\n  ctx.strokeStyle = cellBorderColor;\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n\n  const { w, h } = canvasBox;\n  const { x, y } = canvasBox;\n\n  const rowsVisible = rows.view(y, y + h);\n  const colsVisible = cols.view(x, x + w);\n\n  // Non-Fixed Cells.\n  rowsVisible.forEach((row) => {\n    const hh = row.to - row.from;\n    const fromY = row.from - y;\n    colsVisible.forEach((col) => {\n      const rr = row.index;\n      const cc = col.index;\n      if (rr < fixedRowsCount || cc < fixedColsCount) {\n        return;\n      }\n      const ww = col.to - col.from;\n      const fromX = col.from - x;\n\n      // selected cell background.\n      const selected = anchorCol === cc && anchorRow === rr;\n      let cellStyle;\n      if (selected) {\n        anchorBox = new Box(fromX, fromY, ww, hh);\n        cellStyle = {\n          bgColor: selectionBGColor,\n        };\n      }\n      const text = getCellEntryContent(state, cc, rr);\n      renderCell(ctx, config, new Box(fromX, fromY, ww, hh), text, cellStyle);\n    });\n  });\n  ctx.closePath();\n  ctx.stroke();\n\n  // Anchor Selection Border for non-fixed cells.\n  if (anchorBox) {\n    const { x, y, w, h } = anchorBox;\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = selectionBorderColor;\n    ctx.strokeRect(x, y, w, h);\n  }\n\n  // Fixed col cells drop-shadow.\n  if (x > 0 && fixedColsCount > 0) {\n    const lastCol = cols.peekAt(fixedColsCount - 1);\n    renderFixedShadow(ctx, config, new Box(0, 0, lastCol.to, canvasBox.h));\n  }\n\n  // Fixed col cells.\n  const fixedColStyle = {\n    bgColor: fixedColBGColor,\n  };\n  for (let cc = 0; cc < fixedColsCount; cc++) {\n    const col = cols.peekAt(cc);\n    ctx.clearRect(col.from, 0, col.to - col.from, canvasBox.h);\n    ctx.beginPath();\n    rowsVisible.forEach((row) => {\n      const cc = col.index;\n      const rr = row.index;\n      if (rr < fixedRowsCount) {\n        return;\n      }\n      const selected = anchorCol === cc && anchorRow === rr;\n      const hh = row.to - row.from;\n      const fromX = col.from;\n      const fromY = row.from - y;\n      const toX = col.to;\n      const ww = toX - fromX;\n      const text = getCellEntryContent(state, cc, rr);\n      const cellBox = new Box(fromX, fromY, ww, hh);\n      let cellStyle = fixedColStyle;\n      if (selected) {\n        anchorBox = cellBox;\n        cellStyle = {\n          ...fixedColStyle,\n          bgColor: selectionBGColor,\n        };\n      }\n      renderCell(ctx, config, cellBox, text, cellStyle);\n    });\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  // Fixed row cells drop-shadow.\n  if (y > 0 && fixedRowsCount > 0) {\n    const lastRow = rows.peekAt(fixedRowsCount - 1);\n    renderFixedShadow(ctx, config, new Box(0, 0, canvasBox.w, lastRow.to));\n  }\n\n  // Fixed row cell.\n  const fixedRowCellStyle = {\n    bgColor: fixedRowBGColor,\n  };\n  for (let rr = 0; rr < fixedRowsCount; rr++) {\n    const row = rows.peekAt(rr);\n    const fromY = row.from;\n    const toY = row.to;\n    const hh = toY - fromY;\n    ctx.clearRect(0, fromY, canvasBox.w, hh);\n    ctx.beginPath();\n    colsVisible.forEach((col) => {\n      const cc = col.index;\n      if (cc < fixedColsCount) {\n        return;\n      }\n      const fromX = col.from - x;\n      const toX = col.to - x;\n      const ww = toX - fromX;\n      const text = getCellEntryContent(state, cc, rr);\n      let cellStyle = fixedRowCellStyle;\n      const selected = anchorCol === cc && anchorRow === rr;\n      const cellBox = new Box(fromX, fromY, ww, hh);\n      if (selected) {\n        cellStyle = {\n          ...cellStyle,\n          bgColor: selectionBGColor,\n        };\n        anchorBox = cellBox;\n      }\n      renderCell(ctx, config, cellBox, text, cellStyle);\n    });\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  // Fixed Corner Cells.\n  for (let rr = 0; rr < fixedRowsCount; rr++) {\n    const row = rows.peekAt(rr);\n    for (let cc = 0; cc < fixedColsCount; cc++) {\n      const col = cols.peekAt(cc);\n      const fromX = col.from;\n      const toX = col.to;\n      const fromY = row.from;\n      const toY = row.to;\n      const ww = toX - fromX;\n      const hh = toY - fromY;\n      const text = getCellEntryContent(state, cc, rr);\n      renderCell(\n        ctx,\n        config,\n        new Box(fromX, fromY, ww, hh),\n        text,\n        fixedRowCellStyle,\n      );\n    }\n  }\n\n  // DEV\n  const { devMode } = config;\n  if (devMode) {\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n    const devBox = new Box(canvasBox.w - 60, canvasBox.h - 25, 60, 25);\n    ctx.fillRect(devBox.x, devBox.y, devBox.w, devBox.h);\n    const text = `fps = ${fps | 0}`;\n    ctx.fillStyle = '#fff';\n    ctx.fillText(text, devBox.x + 8, devBox.y + 16);\n  }\n}\n","import Vector from './Vector';\n\nexport default class CellSelection {\n  pos: Vector;\n\n  static create(colIndex: number, rowIndex: number): CellSelection {\n    return new CellSelection(new Vector(colIndex, rowIndex));\n  }\n\n  constructor(cell: Vector) {\n    this.pos = cell;\n  }\n\n  equals(val: CellSelection): boolean {\n    return val.pos.equals(this.pos);\n  }\n}\n","//\n\nexport default class CanvasDataGridConfig {\n  // Style.\n\n  cellBGColor = '#fff';\n  cellBorderColor = '#000';\n  cellPadding = 6;\n  fixedColBGColor = '#f0f0f0';\n  fixedRowBGColor = '#dedede';\n  fontType = 'Arial';\n  indexColWidth = 40;\n  indexRowHeight = 24;\n  selectionBGColor = 'rgb(237,243,254)';\n  selectionBorderColor = 'rgb(80,134,236)';\n  shadowBlur = 10;\n  shadowColor = '#444';\n  textColor = '#222';\n  textSize = 12;\n  // Others\n  fixedColsCount = 1;\n  fixedRowsCount = 1;\n  indexColumnWidth = 60;\n  snapToGrid = false;\n\n  // DEV\n  devMode = !true;\n}\n","const MAX_LENGTH = 10000;\n\ntype Segment = {\n  index: number;\n  from: number;\n  to: number;\n};\n\nexport default class SegmentList {\n  _defaultSegmentSize: number;\n  _segments: Map<number, Segment>;\n\n  constructor(defaultSegmentSize: number) {\n    this._defaultSegmentSize = defaultSegmentSize;\n    this._segments = new Map();\n  }\n\n  peekAt(index: number): Segment {\n    const seg = this._segments.get(index);\n    if (seg) {\n      return seg;\n    }\n    const defaultSegmentSize = this._defaultSegmentSize;\n    let from = index * defaultSegmentSize;\n    for (const [ii, seg] of this._segments) {\n      if (seg.index < index) {\n        const segSize = seg.to - seg.from;\n        from += segSize - defaultSegmentSize;\n      } else {\n        break;\n      }\n    }\n    return {\n      index,\n      from,\n      to: from + defaultSegmentSize,\n    };\n  }\n\n  setSize(index: number, size: number): SegmentList {\n    const defaultSegmentSize = this._defaultSegmentSize;\n    const seg = this.peekAt(index);\n\n    this._segments.set(index, {\n      from: seg.from,\n      to: seg.from + size,\n      index,\n    });\n\n    const deltaSize = size - defaultSegmentSize;\n\n    for (const [ii, seg] of this._segments) {\n      if (seg.index > index) {\n        this._segments.set(index, {\n          from: seg.from + deltaSize,\n          to: seg.to + deltaSize,\n          index,\n        });\n      }\n    }\n\n    return this;\n  }\n\n  // View within range.\n  view(from: number, to: number): Segment[] {\n    const result: Segment[] = [];\n    const size = this._defaultSegmentSize;\n    let upperBound = 0;\n    for (let ii = 0; ii < MAX_LENGTH; ii++) {\n      const seg = this._segments.get(ii) || {\n        index: ii,\n        from: upperBound,\n        to: upperBound + size,\n      };\n      upperBound = seg.to;\n      if (seg.to < from) {\n        continue;\n      }\n      if (\n        (seg.from >= from && seg.from <= to) ||\n        (seg.to <= to && seg.to >= from)\n      ) {\n        result.push(seg);\n      }\n      if (seg.from > to) {\n        break;\n      }\n    }\n    return result;\n  }\n\n  // at point.\n  point(pos: number): Segment | null {\n    let left = 0;\n    let right = MAX_LENGTH;\n    while (true) {\n      const middle = ((left + right) / 2) | 0;\n      const seg = this.peekAt(middle);\n      if (pos >= seg.from && pos <= seg.to) {\n        return seg;\n      }\n      if (pos <= seg.from) {\n        right = middle;\n      }\n      if (pos >= seg.to) {\n        left = middle;\n      }\n      if (left === right) {\n        return null;\n      }\n    }\n  }\n}\n","import type { ProsemirrorProps } from './canvasDataGridState';\nimport CellSelection from './CellSelection';\nimport Box from './Box';\nimport Vector from './Vector';\n\nexport type SetSelectionAction = {\n  type: 'setSelection';\n  selection: CellSelection;\n};\n\nexport type SetProseMirrorPropsAction = {\n  type: 'setProseMirrorProps';\n  props: ProsemirrorProps;\n};\n\nexport type OpenCellEditorAction = {\n  type: 'openCellEditor';\n};\n\nexport type CloseCellEditorAction = {\n  type: 'closeCellEditor';\n  content: string;\n};\n\nexport type SetActiveAction = {\n  type: 'setActive';\n  active: boolean;\n};\n\nexport type SetCanvasBoxAction = {\n  type: 'setCanvasBox';\n  canvasBox: Box;\n};\n\nexport function setSelection(selection: CellSelection): SetSelectionAction {\n  return {\n    type: 'setSelection',\n    selection,\n  };\n}\n\nexport function setProseMirrorProps(\n  props: ProsemirrorProps,\n): SetProseMirrorPropsAction {\n  return {\n    type: 'setProseMirrorProps',\n    props,\n  };\n}\n\nexport function setCanvasBox(canvasBox: Box): SetCanvasBoxAction {\n  return {\n    type: 'setCanvasBox',\n    canvasBox,\n  };\n}\n\nexport function openCellEditor(): OpenCellEditorAction {\n  return {\n    type: 'openCellEditor',\n  };\n}\n\nexport function closeCellEditor(content: string): CloseCellEditorAction {\n  return {\n    type: 'closeCellEditor',\n    content,\n  };\n}\n\nexport function setActive(active: boolean): SetActiveAction {\n  return {\n    type: 'setActive',\n    active,\n  };\n}\n\nexport type CanvasDataGridAction =\n  | CloseCellEditorAction\n  | OpenCellEditorAction\n  | SetCanvasBoxAction\n  | SetProseMirrorPropsAction\n  | SetActiveAction\n  | SetSelectionAction;\n","export type ImportedCSSModule = {\n  locals: Object;\n  toString: () => string;\n};\n\nexport default function createStyleElement(\n  cssModule: ImportedCSSModule,\n): HTMLStyleElement {\n  const el = document.createElement('style');\n  const cssText = cssModule.toString();\n  el.appendChild(document.createTextNode(cssText));\n  return el;\n}\n","import CellEditorSheet from './CellEditor.css';\nimport Vector from './Vector';\nimport { ReducerDispatch } from './canvasDataGridReducer';\nimport type { CanvasDataGridState } from './canvasDataGridState';\nimport { closeCellEditor } from './canvasDataGridActions';\nimport getCellEntryContent from './getCellEntryContent';\nimport createStyleElement from './createStyleElement';\n\nconst styles = CellEditorSheet.locals;\n\nclass State {\n  focusTimer = 0;\n  pos = new Vector(NaN, NaN);\n  visible = false;\n}\n\nexport default class CellEditor {\n  dom: HTMLElement;\n  input: HTMLInputElement;\n  state: State;\n\n  constructor() {\n    const dom = document.createElement('div');\n    const input = document.createElement('input');\n    dom.appendChild(input);\n    dom.className = styles.dom;\n    input.className = styles.input;\n\n    this.state = new State();\n    this.dom = dom;\n    this.input = input;\n    dom.appendChild(createStyleElement(CellEditorSheet));\n  }\n\n  show(\n    state: CanvasDataGridState,\n    dispatch: ReducerDispatch,\n    x: number,\n    y: number,\n  ) {\n    const { dom, input } = this;\n    const { pos, visible } = this.state;\n    const newPos = new Vector(x, y);\n    if (pos.equals(newPos) && visible) {\n      return;\n    }\n    this.state.pos = newPos;\n    this.state.visible = true;\n    dom.style.transform = `translate3d(${x}px,${y}px,0)`;\n    dom.style.visibility = 'visible';\n\n    const cell = state.selection.pos;\n    const submit = () => {\n      const content = input.value;\n      dispatch(closeCellEditor(content));\n    };\n\n    input.value = getCellEntryContent(state, cell.x, cell.y);\n\n    input.onmousedown = (e) => {\n      e.preventDefault();\n    };\n    input.onpaste = (e) => {\n      // block prose-mirror.\n      e.stopImmediatePropagation();\n    };\n    input.oncut = (e) => {\n      // block prose-mirror.\n      e.stopImmediatePropagation();\n    };\n    input.onblur = submit;\n\n    input.onkeydown = (e: KeyboardEvent) => {\n      // block prose-mirror.\n      e.stopImmediatePropagation();\n      // console.log(input.parentNode?.parentNode?.parentNode?.dispatchEvent(ev));\n\n      switch (e.key) {\n        case 'Enter':\n        case 'Escape':\n        case 'Tab':\n          e.preventDefault();\n          submit();\n          break;\n      }\n    };\n    input.onkeypress = (e: KeyboardEvent) => {\n      // Prevent ProseMirror editor from handling this event.\n      e.stopImmediatePropagation();\n    };\n  }\n  focus() {\n    const { input, state } = this;\n    const { visible, focusTimer } = state;\n    if (visible) {\n      clearTimeout(focusTimer);\n      state.focusTimer = setTimeout(() => {\n        input.focus();\n      }, 150);\n    }\n  }\n  hide() {\n    const { dom, state, input } = this;\n    const { focusTimer, visible } = state;\n    if (visible) {\n      state.visible = false;\n      dom.style.visibility = 'hidden';\n      clearTimeout(focusTimer);\n      input.onblur = null;\n      input.onpaste = null;\n      input.oncopy = null;\n      input.onkeydown = null;\n      state.focusTimer = setTimeout(() => {\n        const pe = dom.parentElement;\n        pe && pe.focus();\n      }, 0);\n    }\n  }\n}\n","import Box from './Box';\nimport CanvasDataGridConfig from './CanvasDataGridConfig';\nimport SegmentList from './SegmentList';\nimport CanvasDataGridSheet from './CanvasDataGrid.css';\nimport type { Node as ProsemirrorNode } from 'prosemirror-model';\nimport { Decoration } from 'prosemirror-view';\nimport { EditorView } from 'prosemirror-view';\nimport CellSelection from './CellSelection';\nimport Vector from './Vector';\nimport CellEditor from './CellEditor';\nimport type { CanvasDataGridState } from './canvasDataGridState';\nimport createStyleElement from './createStyleElement';\nimport ProseMirrorDataGridElement from './ProseMirrorDataGridElement';\n\nconst styles = CanvasDataGridSheet.locals;\nconst DEFAULT_ROW_HEIGHT = 32;\nconst DEFAULT_COL_WIDTH = 120;\n\nexport type ProsemirrorProps = {\n  node: ProsemirrorNode;\n  view: EditorView;\n  getPos: (() => number) | boolean;\n  decorations: Decoration[];\n};\n\nfunction createDOM(): ProseMirrorDataGridElement {\n  const dom = ProseMirrorDataGridElement.createElement(document);\n  dom.className = styles.main;\n  dom.tabIndex = 0;\n  dom.appendChild(createStyleElement(CanvasDataGridSheet));\n  return dom;\n}\n\nfunction createCellEditor(dom: ProseMirrorDataGridElement): any {\n  const editor = new CellEditor();\n  dom.appendChild(editor.dom);\n  return editor;\n}\n\nfunction createCanvas(dom: ProseMirrorDataGridElement): HTMLCanvasElement {\n  const canvas = document.createElement('canvas');\n  canvas.className = styles.canvas;\n  dom.appendChild(canvas);\n  return canvas;\n}\n\nexport default function createCanvasDataGridState(props: {\n  proseMirror: ProsemirrorProps;\n}): CanvasDataGridState {\n  const { proseMirror } = props;\n  const config = new CanvasDataGridConfig();\n  const dom = createDOM();\n  const canvasBox = new Box(0, 0, 700, 400);\n  const canvas = createCanvas(dom);\n  const rows = new SegmentList(DEFAULT_ROW_HEIGHT);\n  const cols = new SegmentList(DEFAULT_COL_WIDTH);\n  const selection = new CellSelection(new Vector(1, 1));\n  const cellEditor = createCellEditor(dom);\n  cols.setSize(0, config.indexColumnWidth);\n  rows.setSize(0, config.indexRowHeight);\n  return {\n    active: false,\n    canvas,\n    canvasBox,\n    cellEditor,\n    cols,\n    config,\n    dom,\n    fps: 60,\n    isEditingCell: false,\n    lastRenderedAt: 0,\n    maxColIndex: 26,\n    maxRowIndex: 1000,\n    proseMirror,\n    rows,\n    selection,\n    tr: null,\n  };\n}\n","import Box from './Box';\nimport DOMEventsHandler from './DOMEventsHandler';\nimport Vector from './Vector';\nimport clamp from './clamp';\nimport findCellAtPoint from './findCellAtPoint';\nimport renderCanvasDataGrid from './renderCanvasDataGrid';\nimport CellSelection from './CellSelection';\nimport type {\n  CanvasDataGridState,\n  ProsemirrorProps,\n} from './canvasDataGridState';\nimport type { ReducerDispatch } from './canvasDataGridReducer';\nimport reducer from './canvasDataGridReducer';\nimport type { CanvasDataGridAction } from './canvasDataGridActions';\nimport createCanvasDataGridState from './createCanvasDataGridState';\nimport { TextSelection } from 'prosemirror-state';\nimport {\n  setActive,\n  openCellEditor,\n  setSelection,\n  setCanvasBox,\n} from './canvasDataGridActions';\n\nconst A_Z_KEY = /^[a-zA-Z0-9]$/;\n\nfunction focusElement(el: Element, delay?: number) {\n  if (el instanceof HTMLElement) {\n    if (delay) {\n      setTimeout(() => {\n        el.focus();\n      }, delay || 0);\n    } else {\n      el.focus();\n    }\n  }\n}\n\nfunction renderDOM(state: CanvasDataGridState) {\n  const { dom, active } = state;\n  const el: any = dom;\n  if (active !== el.__active) {\n    el.__active = active;\n    dom.setAttribute('data-active', String(active));\n  }\n}\n\nfunction renderCellEditor(\n  state: CanvasDataGridState,\n  dispatch: ReducerDispatch,\n) {\n  const { selection, rows, cols, cellEditor, isEditingCell, canvasBox } = state;\n  const col = isEditingCell && cols.peekAt(selection.pos.x);\n  const row = isEditingCell && rows.peekAt(selection.pos.y);\n  if (!col || !row) {\n    cellEditor.hide();\n  } else {\n    const { x, y } = canvasBox;\n    cellEditor.show(state, dispatch, col.from - x, row.from - y);\n    cellEditor.focus();\n  }\n}\n\nfunction createDOMEventsHandler(\n  dom: HTMLElement,\n  datagrid: CanvasDataGrid,\n): DOMEventsHandler {\n  const domEventsHandler = new DOMEventsHandler();\n  domEventsHandler.onWheel(dom, datagrid.onWheel, true);\n  domEventsHandler.onMouseDown(dom, datagrid.onMouseDown, true);\n  domEventsHandler.onKeyDown(dom, datagrid.onKeyDown, true);\n  domEventsHandler.onFocusIn(dom, datagrid.onFocusChange, true);\n  domEventsHandler.onFocusOut(dom, datagrid.onFocusChange, true);\n  return domEventsHandler;\n}\n\nfunction shouldHandleEvent(e: Event, state: CanvasDataGridState) {\n  const { dom, canvas, isEditingCell } = state;\n  const { target } = e;\n  return !isEditingCell || dom === target || canvas === target;\n}\n\nfunction onFocusChange(\n  e: Event,\n  state: CanvasDataGridState,\n  dispatch: ReducerDispatch,\n) {\n  const { dom } = state;\n  const { activeElement } = document;\n  const active = activeElement\n    ? activeElement === dom || dom.contains(activeElement)\n    : false;\n  dispatch(setActive(active));\n}\n\nfunction onKeyDown(\n  e: KeyboardEvent,\n  state: CanvasDataGridState,\n  dispatch: ReducerDispatch,\n) {\n  if (!shouldHandleEvent(e, state)) {\n    return;\n  }\n\n  if (e.ctrlKey || e.metaKey) {\n    // reload / redu / undo...etc.\n    return;\n  }\n\n  e.preventDefault();\n\n  const { proseMirror, selection, maxColIndex, maxRowIndex } = state;\n  const { getPos, view } = proseMirror;\n  const { key, ctrlKey, metaKey } = e;\n\n  if (key === 'Escape') {\n    const pos = typeof getPos === 'function' ? getPos() : 0;\n    if (pos > 0) {\n      const delta = e.shiftKey ? -1 : 1;\n      const selection = TextSelection.create(view.state.doc, pos + delta);\n      const tr = view.state.tr.setSelection(selection);\n      focusElement(view.dom);\n      view.dispatch(tr);\n    }\n    return;\n  }\n\n  if (key === 'ArrowLeft') {\n    const { pos } = selection;\n    const x = pos.x - 1;\n    if (x > 0) {\n      dispatch(setSelection(CellSelection.create(x, pos.y)));\n    }\n    return;\n  }\n\n  if (key === 'ArrowRight') {\n    const { pos } = selection;\n    const x = pos.x + 1;\n    if (x <= maxColIndex) {\n      dispatch(setSelection(CellSelection.create(x, pos.y)));\n    }\n    return;\n  }\n\n  if (key === 'ArrowDown') {\n    const { pos } = selection;\n    const y = pos.y + 1;\n    if (y <= maxRowIndex) {\n      dispatch(setSelection(CellSelection.create(pos.x, y)));\n    }\n    return;\n  }\n\n  if (key === 'ArrowUp') {\n    const { pos } = selection;\n    const y = pos.y - 1;\n    if (y > 0) {\n      dispatch(setSelection(CellSelection.create(pos.x, y)));\n    }\n    return;\n  }\n\n  if (key === 'Tab') {\n    const { pos } = selection;\n    const delta = e.shiftKey ? -1 : 1;\n    let x = pos.x + delta;\n    let y = pos.y;\n    if (x > maxColIndex) {\n      x = 1;\n      y += 1;\n    }\n    if (x < 1) {\n      x = maxColIndex;\n      y -= 1;\n    }\n\n    if (y >= 1 && y <= maxRowIndex) {\n      dispatch(setSelection(CellSelection.create(x, y)));\n    }\n\n    return;\n  }\n\n  if (key === 'Enter' || (A_Z_KEY.test(key) && !ctrlKey && !metaKey)) {\n    dispatch(openCellEditor());\n    return;\n  }\n}\n\nfunction onMouseDown(\n  e: MouseEvent,\n  state: CanvasDataGridState,\n  dispatch: ReducerDispatch,\n) {\n  if (!shouldHandleEvent(e, state)) {\n    return;\n  }\n\n  const { selection, isEditingCell } = state;\n  const { offsetX, offsetY } = e;\n  e.preventDefault();\n\n  if (isEditingCell) {\n    return;\n  }\n\n  const cell = findCellAtPoint(state, new Vector(offsetX, offsetY));\n  if (cell) {\n    const { x, y } = cell;\n    let nextSelection;\n    if (x === 0 && y === 0) {\n      // top-left corner.\n    } else if (y > 0 && x === 0) {\n      // row selection.\n    } else if (x > 0 && y === 0) {\n      //\n    } else {\n      nextSelection = new CellSelection(cell);\n    }\n    if (!nextSelection) {\n      return;\n    }\n    if (nextSelection.equals(selection)) {\n      dispatch(openCellEditor());\n    } else {\n      dispatch(setSelection(nextSelection));\n    }\n  }\n}\n\nfunction onWheel(\n  e: WheelEvent,\n  state: CanvasDataGridState,\n  dispatch: ReducerDispatch,\n) {\n  if (!shouldHandleEvent(e, state)) {\n    return;\n  }\n\n  e.preventDefault();\n\n  const { config, rows, cols, isEditingCell } = state;\n  let { canvasBox } = state;\n  const { deltaY, deltaX } = e;\n\n  if (isEditingCell) {\n    return;\n  }\n\n  if (config.snapToGrid) {\n    const row = rows.view(canvasBox.y, canvasBox.y + 1)[0];\n    if (row) {\n      if (deltaY > 0) {\n        // back\n        const { x, w, h } = canvasBox;\n        if (row.index > 0) {\n          const nextRow = rows.peekAt(row.index - 1);\n          const y = nextRow.to;\n          canvasBox = new Box(x, y, w, h);\n        } else {\n          canvasBox = new Box(x, 0, w, h);\n        }\n      } else if (deltaY < 0) {\n        // forward.\n        const { x, w, h } = canvasBox;\n        const nextRow = rows.peekAt(row.index + 1);\n        const y = nextRow.to;\n        canvasBox = new Box(x, y, w, h);\n      }\n    }\n    const col = cols.view(canvasBox.x, canvasBox.x + 1)[0];\n    if (col) {\n      if (deltaX > 0) {\n        // back\n        const { y, w, h } = canvasBox;\n        if (col.index > 0) {\n          const nextCol = cols.peekAt(col.index - 1);\n          const x = nextCol.from;\n          canvasBox = new Box(x, y, w, h);\n        } else {\n          canvasBox = new Box(0, y, w, h);\n        }\n      } else if (deltaX < 0) {\n        // forward.\n        const { y, w, h } = canvasBox;\n        const nextCol = cols.peekAt(col.index + 1);\n        const x = nextCol.to;\n        canvasBox = new Box(x, y, w, h);\n      }\n    }\n  } else {\n    const x = clamp(canvasBox.x - deltaX, 0, 10000);\n    const y = clamp(canvasBox.y - deltaY, 0, 10000);\n    canvasBox = new Box(x, y, canvasBox.w, canvasBox.h);\n  }\n\n  if (!state.canvasBox.equals(canvasBox)) {\n    dispatch(setCanvasBox(canvasBox));\n  }\n}\n\nexport default class CanvasDataGrid {\n  // Public.\n  state: CanvasDataGridState;\n\n  // Members.\n  domEventsHandler: DOMEventsHandler;\n\n  constructor(proseMirror: ProsemirrorProps) {\n    this.state = createCanvasDataGridState({ proseMirror });\n    this.domEventsHandler = createDOMEventsHandler(this.state.dom, this);\n    this._render();\n  }\n\n  dispatch = (action: CanvasDataGridAction) => {\n    const nextState = reducer(action, this.state);\n    if (!nextState) {\n      return;\n    }\n\n    const { tr, proseMirror } = nextState;\n    if (tr) {\n      nextState.tr = null;\n    }\n    this.state = nextState;\n    requestAnimationFrame(this._render);\n    tr && proseMirror.view.dispatch(tr);\n  };\n\n  focus() {\n    this.state.dom.focus();\n  }\n\n  destroy() {\n    this.domEventsHandler.destroy();\n  }\n\n  onMouseDown = (e: MouseEvent) => {\n    const { target } = e;\n    const { canvas, dom } = this.state;\n    if (target === canvas || target === dom) {\n      onMouseDown(e, this.state, this.dispatch);\n      this.focus();\n    }\n  };\n\n  onWheel = (e: WheelEvent) => {\n    onWheel(e, this.state, this.dispatch);\n  };\n\n  onKeyDown = (e: KeyboardEvent) => {\n    onKeyDown(e, this.state, this.dispatch);\n  };\n\n  onFocusChange = (e: Event) => {\n    onFocusChange(e, this.state, this.dispatch);\n  };\n\n  _render = () => {\n    const { state } = this;\n    renderDOM(state);\n    renderCellEditor(state, this.dispatch);\n    renderCanvasDataGrid(state);\n  };\n}\n","import type {\n  CanvasDataGridState,\n  CanvasDataGridStateChange,\n} from './canvasDataGridState';\nimport findCellBox from './findCellBox';\nimport type {\n  CanvasDataGridAction,\n  CloseCellEditorAction,\n  OpenCellEditorAction,\n  SetActiveAction,\n  SetCanvasBoxAction,\n  SetProseMirrorPropsAction,\n  SetSelectionAction,\n} from './canvasDataGridActions';\nimport setCellEntryContent from './setCellEntryContent';\nimport Box from './Box';\n\nexport type ReducerDispatch = (action: CanvasDataGridAction) => void;\n\nfunction getFixedRowsHeight(state: CanvasDataGridState): number {\n  const { config, rows } = state;\n  const row = rows.peekAt(config.fixedRowsCount - 1);\n  return row.to;\n}\n\nfunction getFixedColsWidth(state: CanvasDataGridState): number {\n  const { config, cols } = state;\n  const row = cols.peekAt(config.fixedColsCount - 1);\n  return row.to;\n}\n\nfunction setSelection(\n  action: SetSelectionAction,\n  state: CanvasDataGridState,\n  changes: CanvasDataGridStateChange,\n) {\n  const { canvasBox } = state;\n  const { selection } = action;\n  const cellBox = findCellBox(state, selection.pos);\n  let newCanvasBox = canvasBox;\n\n  if (cellBox) {\n    const cw = getFixedColsWidth(state);\n    const rh = getFixedRowsHeight(state);\n    const viewpotBox = new Box(\n      newCanvasBox.x + cw,\n      newCanvasBox.y + rh,\n      newCanvasBox.w - cw,\n      newCanvasBox.h - rh,\n    );\n    let dx = 0;\n    let dy = 0;\n    if (cellBox.x < viewpotBox.x) {\n      dx = -(viewpotBox.x - cellBox.x);\n    }\n\n    if (cellBox.x + cellBox.w > viewpotBox.x + viewpotBox.w) {\n      dx = cellBox.x + cellBox.w - viewpotBox.x - viewpotBox.w;\n    }\n    if (cellBox.y <= viewpotBox.y) {\n      dy = -(viewpotBox.y - cellBox.y, cellBox.h);\n    }\n    if (cellBox.y + cellBox.h >= viewpotBox.y + viewpotBox.h) {\n      dy = cellBox.y + cellBox.h - viewpotBox.y - viewpotBox.h;\n    }\n    newCanvasBox = newCanvasBox.moveBy(dx, dy);\n  }\n\n  const { x, y } = newCanvasBox;\n  newCanvasBox = newCanvasBox.moveBy(x < 0 ? -x : 0, y < 0 ? -y : 0);\n\n  if (!newCanvasBox.equals(canvasBox)) {\n    changes.canvasBox = newCanvasBox;\n  }\n\n  changes.selection = selection;\n}\n\nfunction setProseMirrorProps(\n  action: SetProseMirrorPropsAction,\n  state: CanvasDataGridState,\n  changes: CanvasDataGridStateChange,\n) {\n  const proseMirror = action.props;\n  changes.proseMirror = proseMirror;\n}\n\nfunction setCanvasBox(\n  action: SetCanvasBoxAction,\n  state: CanvasDataGridState,\n  changes: CanvasDataGridStateChange,\n) {\n  const { canvasBox } = action;\n  changes.canvasBox = canvasBox;\n}\n\nfunction openCellEditor(\n  action: OpenCellEditorAction,\n  state: CanvasDataGridState,\n  changes: CanvasDataGridStateChange,\n) {\n  changes.isEditingCell = true;\n}\n\nfunction closeCellEditor(\n  action: CloseCellEditorAction,\n  state: CanvasDataGridState,\n  changes: CanvasDataGridStateChange,\n) {\n  changes.isEditingCell = false;\n\n  const editorState = state.proseMirror.view.state;\n  const { tr, schema } = editorState;\n  const { content } = action;\n  const { getPos } = state.proseMirror;\n  const cell = state.selection.pos;\n  const pos = typeof getPos === 'function' ? getPos() : 0;\n  changes.tr = setCellEntryContent(schema, tr, pos, cell.x, cell.y, content);\n}\n\nfunction setActive(\n  action: SetActiveAction,\n  state: CanvasDataGridState,\n  changes: CanvasDataGridStateChange,\n) {\n  changes.active = action.active;\n}\n\n// TODO: Avoid side-effect. It should not need to mutate the original state.\nexport default function canvasDataGridReducer(\n  action: CanvasDataGridAction,\n  state: CanvasDataGridState,\n): CanvasDataGridState | null {\n  const changes: CanvasDataGridStateChange = {};\n  switch (action.type) {\n    case 'setProseMirrorProps':\n      setProseMirrorProps(action, state, changes);\n      break;\n\n    case 'setActive':\n      setActive(action, state, changes);\n      break;\n\n    case 'setSelection':\n      setSelection(action, state, changes);\n      break;\n\n    case 'setCanvasBox':\n      setCanvasBox(action, state, changes);\n      break;\n\n    case 'openCellEditor':\n      openCellEditor(action, state, changes);\n      break;\n\n    case 'closeCellEditor':\n      closeCellEditor(action, state, changes);\n      break;\n\n    default:\n      return null;\n  }\n  let changed = false;\n  const changesMap: any = changes;\n  const mutatableState: any = state;\n  for (const prop in changesMap) {\n    const value = changesMap[prop];\n    if (value !== mutatableState[prop]) {\n      mutatableState[prop] = value;\n      changed = true;\n    }\n  }\n  if (!changed) {\n    return null;\n  }\n\n  return mutatableState;\n}\n","import Vector from './Vector';\nimport Box from './Box';\nimport type { CanvasDataGridState } from './canvasDataGridState';\n\nexport default function findCellBox(\n  state: CanvasDataGridState,\n  cell: Vector,\n): Box | null {\n  const { rows, cols } = state;\n  const row = rows.peekAt(cell.y);\n  const col = cols.peekAt(cell.x);\n  if (row && col) {\n    return new Box(col.from, row.from, col.to - col.from, row.to - row.from);\n  }\n  return null;\n}\n","import { Transaction } from 'prosemirror-state';\nimport { Schema } from 'prosemirror-model';\nimport { NODE_NAME } from './DataGridNodeSpec';\nimport Vector from './Vector';\nimport getCellEntryKey from './getCellEntryKey';\n\nexport default function setCellEntryContent(\n  schema: Schema,\n  tr: Transaction,\n  pos: number,\n  colIndex: number,\n  rowIndex: number,\n  content: string,\n): Transaction {\n  const nodeType = schema.nodes[NODE_NAME];\n  if (!nodeType) {\n    return tr;\n  }\n  const node = tr.doc.nodeAt(pos);\n  if (!node) {\n    throw new Error(`Unable to find Node at ${pos}`);\n  }\n  if (node.type !== nodeType) {\n    throw new Error(\n      `Expect Node to be ${NODE_NAME}, received ${node.type.name}`,\n    );\n  }\n  const { marks, attrs } = node;\n  const key = getCellEntryKey(colIndex, rowIndex);\n  const newAttrs = {\n    ...attrs,\n    entries: {\n      ...attrs.entries,\n      [key]: content,\n    },\n  };\n  tr = tr.setNodeMarkup(pos, nodeType, newAttrs, marks);\n  return tr;\n}\n","import Vector from './Vector';\nimport type { CanvasDataGridState } from './canvasDataGridState';\n\nexport default function findCellAtPoint(\n  state: CanvasDataGridState,\n  point: Vector,\n): Vector | null {\n  const { config, canvasBox, cols, rows } = state;\n\n  let col;\n\n  let row;\n  const { fixedColsCount, fixedRowsCount } = config;\n  if (fixedColsCount) {\n    col = cols.point(point.x);\n    if (col && col.index > fixedColsCount - 1) {\n      col = null;\n    }\n  }\n\n  if (fixedRowsCount) {\n    row = rows.point(point.y);\n    if (row && row.index > fixedRowsCount - 1) {\n      row = null;\n    }\n  }\n\n  if (!col) {\n    col = cols.point(point.x + canvasBox.x);\n  }\n\n  if (!row) {\n    row = rows.point(point.y + canvasBox.y);\n  }\n\n  if (!col || !row) {\n    return null;\n  }\n  return new Vector(col.index, row.index);\n}\n","import { Decoration, NodeView } from 'prosemirror-view';\nimport type { Node as ProsemirrorNode } from 'prosemirror-model';\nimport CanvasDataGrid from './CanvasDataGrid';\nimport type { ProsemirrorProps } from './canvasDataGridState';\n\nexport default class DataGridNodeView {\n  datagrid: CanvasDataGrid;\n  dom: Node | null;\n  props: ProsemirrorProps;\n  selected: boolean;\n\n  constructor(props: ProsemirrorProps) {\n    const datagrid = new CanvasDataGrid(props);\n    this.datagrid = datagrid;\n    this.dom = datagrid.state.dom;\n    this.props = props;\n    this.selected = false;\n  }\n\n  update(node: ProsemirrorNode, decorations: Decoration[]) {\n    const { dom, props } = this;\n    if (props.node.type === node.type && dom instanceof HTMLElement) {\n      const nextProps = { ...props, node, decorations };\n      this.props = nextProps;\n      this.datagrid.dispatch({\n        type: 'setProseMirrorProps',\n        props: nextProps,\n      });\n    }\n    return true;\n  }\n\n  selectNode() {\n    if (!this.selected) {\n      this.selected = true;\n      this.datagrid.focus();\n    }\n  }\n\n  deselectNode() {\n    if (this.selected) {\n      this.selected = false;\n    }\n  }\n\n  stopEvent = (event: Event) => {\n    return event.defaultPrevented;\n  };\n\n  destroy() {\n    this.datagrid.destroy();\n  }\n}\n","import { Decoration, NodeView } from 'prosemirror-view';\nimport { NODE_NAME } from './DataGridNodeSpec';\nimport { EditorView } from 'prosemirror-view';\nimport type { Node as ProsemirrorNode } from 'prosemirror-model';\n\nimport DataGridNodeView from './DataGridNodeView';\n\nexport type NodeViewRenderer = (\n  node: ProsemirrorNode,\n  view: EditorView,\n  getPos: (() => number) | boolean,\n  decorations: Decoration[],\n) => NodeView;\n\n// Allows you to pass custom rendering and behavior logic for nodes and marks.\n// Should map node and mark names to constructor functions that produce a\n// NodeView object implementing the node's display behavior.\nexport default function createNodeViewsMap(): {\n  [name: string]: NodeViewRenderer;\n} {\n  return {\n    [NODE_NAME]: (\n      node: ProsemirrorNode,\n      view: EditorView,\n      getPos: (() => number) | boolean,\n      decorations: Decoration[],\n    ) => {\n      return new DataGridNodeView({ node, view, getPos, decorations });\n    },\n  };\n}\n"],"names":["root","factory","exports","module","define","amd","self","___CSS_LOADER_EXPORT___","push","id","locals","cssWithMappingToString","list","toString","this","map","item","content","concat","join","i","modules","mediaQuery","dedupe","alreadyImportedModules","length","_i","_arrayLikeToArray","arr","len","arr2","Array","_item","isArray","_arrayWithHoles","Symbol","iterator","_s","_e","_arr","_n","_d","call","next","done","value","err","_iterableToArrayLimit","o","minLen","n","Object","prototype","slice","constructor","name","from","test","_unsupportedIterableToArray","TypeError","_nonIterableRest","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","sourceURLs","sources","source","sourceRoot","nullthrows","x","message","error","Error","undefined","framesToPop","defineProperty","OrderedMap","find","key","get","found","update","newKey","remove","splice","addToStart","addToEnd","addBefore","place","without","forEach","f","prepend","size","subtract","append","result","prop","findDiffStart","a","b","pos","childCount","childA","child","childB","sameMarkup","isText","text","j","inner","nodeSize","findDiffEnd","posA","posB","iA","iB","same","minSize","Math","min","Fragment","prototypeAccessors","firstChild","configurable","lastChild","nodesBetween","to","nodeStart","parent","end","start","max","descendants","textBetween","blockSeparator","leafText","separated","node","isLeaf","isBlock","other","last","first","withText","cut","cutByIndex","empty","replaceChild","index","current","copy","eq","RangeError","maybeChild","p","otherPos","findIndex","round","retIndex","curPos","toStringInner","toJSON","fromJSON","schema","nodeFromJSON","fromArray","array","joined","nodes","attrs","defineProperties","offset","compareDeep","p$1","Mark","type","ReplaceError","__proto__","addToSet","set","placed","excludes","rank","removeFromSet","isInSet","obj","_","json","marks","create","sameSet","setFrom","none","sort","Slice","openStart","openEnd","prototypeAccessors$1","removeRange","ref","ref$1","indexTo","offsetTo","insertInto","dist","insert","canReplace","replace","$from","$to","depth","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","close","replaceThreeWay","parentOffset","replaceTwoWay","checkJoin","main","sub","compatibleContent","joinable","$before","$after","addNode","target","addRange","$start","$end","startIndex","endIndex","textOffset","nodeAfter","nodeBefore","validContent","insertAt","fragment","removeBetween","maxOpen","openIsolating","spec","isolating","n$1","ResolvedPos","path","prototypeAccessors$2","doc","resolveDepth","val","indexAfter","before","after","dOff","posAtIndex","tmp","inclusive","marksAcross","isInline","sharedDepth","blockRange","pred","d","inlineContent","NodeRange","sameParent","str","resolve","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1$1","emptyAttrs","Node","prototypeAccessors$3","textContent","isTextblock","isAtom","startPos","hasMarkup","defaultAttrs","mark","includeParents","nodeAt","childAfter","childBefore","rangeHasMark","toDebugString","wrapMarks","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","check","m","markFromJSON","nodeType","TextNode","base","ContentMatch","wrapCache","prototypeAccessors$4","defaultType","edgeCount","parse","string","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","connect","compile","exprs","reduce","out","loop","edge","loop$1","cur","i$1","next$1","i$2","next$2","term","edges","explore","states","known","indexOf","nullFrom","state","states$1","cmp","work","dead","hasRequiredAttrs","checkForDeadEnds","frag","compatible","fillBefore","toEnd","seen","search","types","finished","tp","createAndFill","findWrapping","computed","computeWrapping","active","via","shift","reverse","scan","inline","tokens","split","pop","prototypeAccessors$1$2","parseExprSeq","eat","parseExprSubscript","typeName","type$1","groups","resolveName","parseExprAtom","parseExprRange","parseNum","Number","defaults","attrName","attr","hasDefault","default","computeAttrs","built","given","initAttrs","Attribute","tok","SyntaxError","NodeType","group","markSet","prototypeAccessors$5","atom","isRequired","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","options","hasOwnProperty","prototypeAccessors$1$3","MarkType","excluded","instance","Schema","contentExprCache","prop$1","contentExpr","markExpr","gatherMarks","prop$2","excl","bind","topNodeType","wrappings","ok","mark$1","text$1","DOMParser","rules","this$1","tags","styles","rule","tag","style","normalizeLists","some","r","dom","context","ParseContext","addAll","finish","parseSlice","matchTag","matches","namespace","namespaceURI","matchesContext","getAttrs","matchStyle","charCodeAt","schemaRules","priority","rules$1","parseDOM","name$1","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","wsOptionsFor","preserveWhitespace","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","wrap","exec","popFromStashMark","applyPending","nextType","pending","markMayApply","inlineContext","parentNode","nodeName","toLowerCase","parser","open","isOpen","topContext","topOptions","topMatch","findPositions","needsBlock","prototypeAccessors$6","top","currentPos","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","v","returned","addDOM","addTextNode","getAttribute","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","insertNode","findInText","findInside","matchAfter","ruleID","prevItem","nextSibling","appendChild","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","childNodes","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","topOpen","contains","compareDocumentPosition","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","lastIndexOf","stashMark","DOMSerializer","gatherToDOM","toDOM","document","window","serializeFragment","createDocumentFragment","keep","rendered","spanning","add","markDOM","serializeMark","serializeNodeInner","renderSpec","onContent","serializeNode","structure","xmlNS","tagName","space","createElementNS","createElement","space$1","setAttributeNS","setAttribute","innerContent","domSerializer","nodesFromSchema","marksFromSchema","classesById","Selection","$anchor","$head","ranges","SelectionRange","anchor","tr","lastNode","lastParent","mapFrom","steps","mapping","replaceRange","selectionToInsertionEnd","replaceWith","deleteRange","replaceRangeWith","findFrom","$pos","dir","textOnly","TextSelection","findSelectionIn","near","bias","AllSelection","atStart","atEnd","cls","jsonID","selectionClass","getBookmark","between","visible","$cursor","ensureMarks","TextBookmark","dPos","NodeSelection","mapResult","deleted","NodeBookmark","isSelectable","selectable","delete","sel","selection","setSelection","AllBookmark","startLen","step","maps","_from","_to","_newFrom","newTo","Transaction","Transform","time","Date","now","curSelection","curSelectionFor","storedMarks","updated","meta","selectionSet","storedMarksSet","isGeneric","scrolledIntoView","setStoredMarks","addStoredMark","removeStoredMark","addStep","setTime","replaceSelection","replaceSelectionWith","inheritMarks","deleteSelection","insertText","setMeta","getMeta","scrollIntoView","FieldDesc","desc","init","apply","baseFields","config","_marks","_old","prev","Configuration","plugins","fields","pluginsByKey","plugin","EditorState","applyTransaction","filterTransaction","rootTr","transactions","trs","newState","applyInner","haveNew","appendTransaction","oldState","newInstance","field","applyListeners","$config","reconfigure","pluginFields","addApplyListener","removeApplyListener","bindProps","Function","props","createKey","getState","keys","PluginKey","factor16","pow","recoverIndex","MapResult","recover","StepMap","inverted","diff","recoverOffset","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","oldStart","newStart","invert","Mapping","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","docs","docChanged","mustOverride","maybeStep","failed","getMap","stepsByID","Step","_doc","_mapping","merge","_other","stepType","stepClass","StepResult","fail","fromReplace","e","ReplaceStep","contentBetween","slice$1","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","mapFragment","mapped","lift","range","gapStart","gapEnd","splitting","d$1","splitting$1","wrappers","setBlockType","canChangeType","clearIncompatible","startM","endM","setNodeMarkup","newNode","typesAfter","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","fitsTrivially","addMark","removed","added","removing","adding","newSet","s","removeMark","matched","toRemove","found$1","parentType","delSteps","allowed","Fitter","fit","replaceStep","unplaced","frontier","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","pass","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","findCloseLevel","dropInner","match$1","move","targetDepths","preferredTarget","unshift","defining","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","point","index$1","insertPoint","covered","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","definition","enumerable","toStringTag","NODE_NAME","defineElement","customElements","ProseMirrorDataGridElement","HTMLElement","entries","draggable","insertDataGrid","createNodeSpecMap","DataGridNodeSpec","Vector","y","deg","dx","dy","atan2","PI","Box","w","h","box","intersects","DOMEventsHandler","_entries","entry","capture","listener","removeEventListener","_onMouseEvent","_onEvent","_onKeyboardEvent","addEventListener","clamp","RE_FONT_VALUE","DeviceRenderingContext","ctx","dpi","devicePixelRatio","fontSize","parseInt","fontType","font","strokeStyle","lineWidth","fillStyle","shadowBlur","shadowColor","maxWidth","fillText","clearRect","strokeRect","fillRect","moveTo","lineTo","stroke","beginPath","closePath","getCellEntryKey","colIndex","rowIndex","cachedResult","Map","numToAZ","num","String","fromCharCode","getIndexRowCellText","has","getCellEntryContent","proseMirror","renderCell","cellBox","cellPadding","textSize","textColor","cellBGColor","cellBorderColor","bgColor","borderColor","renderFixedShadow","shadowBox","CellSelection","cell","equals","CanvasDataGridConfig","SegmentList","defaultSegmentSize","_defaultSegmentSize","_segments","seg","peekAt","deltaSize","upperBound","ii","left","right","middle","createStyleElement","cssModule","el","cssText","CellEditorSheet","State","NaN","CellEditor","input","className","dispatch","newPos","transform","visibility","submit","closeCellEditor","onmousedown","preventDefault","onpaste","stopImmediatePropagation","oncut","onblur","onkeydown","onkeypress","focusTimer","clearTimeout","setTimeout","focus","oncopy","pe","parentElement","CanvasDataGridSheet","createCanvasDataGridState","tabIndex","createDOM","canvasBox","createCanvas","rows","cols","cellEditor","editor","createCellEditor","setSize","indexColumnWidth","indexRowHeight","fps","isEditingCell","lastRenderedAt","maxColIndex","maxRowIndex","A_Z_KEY","shouldHandleEvent","CanvasDataGrid","datagrid","domEventsHandler","action","nextState","changes","setProseMirrorProps","setActive","row","col","findCellBox","newCanvasBox","cw","fixedColsCount","getFixedColsWidth","rh","fixedRowsCount","getFixedRowsHeight","viewpotBox","moveBy","setCanvasBox","openCellEditor","editorState","view","getPos","newAttrs","setCellEntryContent","changed","changesMap","mutatableState","reducer","requestAnimationFrame","_render","offsetX","offsetY","findCellAtPoint","nextSelection","onMouseDown","deltaY","deltaX","snapToGrid","onWheel","ctrlKey","metaKey","delta","shiftKey","onKeyDown","activeElement","__active","renderDOM","show","hide","renderCellEditor","fixedColBGColor","fixedRowBGColor","selectionBGColor","selectionBorderColor","anchorCol","anchorRow","anchorBox","CanvasDataGridRenderingContext","getContext","width","height","setCanvasSize","rowsVisible","colsVisible","hh","fromY","rr","cc","cellStyle","ww","fromX","lastCol","fixedColStyle","selected","lastRow","fixedRowCellStyle","toX","devMode","devBox","renderCanvasDataGrid","onFocusIn","onFocusChange","onFocusOut","destroy","DataGridNodeView","event","defaultPrevented","decorations","nextProps","createNodeViewsMap"],"sourceRoot":""}